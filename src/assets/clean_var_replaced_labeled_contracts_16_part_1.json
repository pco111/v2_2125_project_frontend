[
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\ncontract LedgeriumToken is ERC20 {\n    uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n}",
    "type": "correct"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  bool not_called_xxx20 = true;\nfunction xx_xxx20() public{\n        require(not_called_xxx20);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx20 = false;\n    }\n  mapping (address => uint256) private _balances;\n  bool not_called_xxx34 = true;\nfunction xx_xxx34() public{\n        require(not_called_xxx34);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx34 = false;\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  mapping(address => uint) balances_xxx1;\n    function withdraw_balances_xxx1 () public {\n       (bool success,) =msg.sender.call.value(balances_xxx1[msg.sender ])(\"\");\n       if (success)\n          balances_xxx1[msg.sender] = 0;\n      }\n  uint256 private _totalSupply;\n  address payable lastPlayer_xxx2;\n      uint jackpot_xxx2;\n\t  function buyTicket_xxx2() public{\n\t    if (!(lastPlayer_xxx2.send(jackpot_xxx2)))\n        revert();\n      lastPlayer_xxx2 = msg.sender;\n      jackpot_xxx2    = address(this).balance;\n    }\n  string private _name;\n  mapping(address => uint) balances_xxx3;\nfunction withdrawFunds_xxx3 (uint256 _weiToWithdraw) public {\n        require(balances_xxx3[msg.sender] >= _weiToWithdraw);\n\t(bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx3[msg.sender] -= _weiToWithdraw;\n    }\n  string private _symbol;\n  bool not_called_xxx41 = true;\nfunction xx_xxx41() public{\n        require(not_called_xxx41);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx41 = false;\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nbool not_called_xxx6 = true;\nfunction xx_xxx6() public{\n        require(not_called_xxx6);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx6 = false;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nmapping(address => uint) userBalance_xxx40;\nfunction withdrawBalance_xxx40() public{\n        (bool success,)=msg.sender.call.value(userBalance_xxx40[msg.sender])(\"\");\n        if( ! success ){\n            revert();\n        }\n        userBalance_xxx40[msg.sender] = 0;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nmapping(address => uint) redeemableEther_xxx4;\nfunction claimReward_xxx4() public {        \n        require(redeemableEther_xxx4[msg.sender] > 0);\n        uint transferValue_xxx4 = redeemableEther_xxx4[msg.sender];\n        msg.sender.transfer(transferValue_xxx4);   \n        redeemableEther_xxx4[msg.sender] = 0;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nuint256 counter_xxx42 =0;\nfunction callme_xxx42() public{\n        require(counter_xxx42<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx42 += 1;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nmapping(address => uint) userBalance_xxx5;\nfunction withdrawBalance_xxx5() public{\n        if( ! (msg.sender.send(userBalance_xxx5[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx5[msg.sender] = 0;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nmapping(address => uint) balances_xxx8;\n    function withdraw_balances_xxx8 () public {\n       (bool success,) = msg.sender.call.value(balances_xxx8[msg.sender ])(\"\");\n       if (success)\n          balances_xxx8[msg.sender] = 0;\n      }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress payable lastPlayer_xxx9;\n      uint jackpot_xxx9;\n\t  function buyTicket_xxx9() public{\n\t    (bool success,) = lastPlayer_xxx9.call.value(jackpot_xxx9)(\"\");\n\t    if (!success)\n\t        revert();\n      lastPlayer_xxx9 = msg.sender;\n      jackpot_xxx9    = address(this).balance;\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nmapping(address => uint) redeemableEther_xxx11;\nfunction claimReward_xxx11() public {        \n        require(redeemableEther_xxx11[msg.sender] > 0);\n        uint transferValue_xxx11 = redeemableEther_xxx11[msg.sender];\n        msg.sender.transfer(transferValue_xxx11);   \n        redeemableEther_xxx11[msg.sender] = 0;\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nmapping(address => uint) redeemableEther_xxx39;\nfunction claimReward_xxx39() public {        \n        require(redeemableEther_xxx39[msg.sender] > 0);\n        uint transferValue_xxx39 = redeemableEther_xxx39[msg.sender];\n        msg.sender.transfer(transferValue_xxx39);   \n        redeemableEther_xxx39[msg.sender] = 0;\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nmapping(address => uint) balances_xxx38;\nfunction withdrawFunds_xxx38 (uint256 _weiToWithdraw) public {\n        require(balances_xxx38[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx38[msg.sender] -= _weiToWithdraw;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx10;\nfunction withdrawFunds_xxx10 (uint256 _weiToWithdraw) public {\n        require(balances_xxx10[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx10[msg.sender] -= _weiToWithdraw;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nmapping(address => uint) userBalance_xxx12;\nfunction withdrawBalance_xxx12() public{\n        if( ! (msg.sender.send(userBalance_xxx12[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx12[msg.sender] = 0;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nbool not_called_xxx13 = true;\nfunction xx_xxx13() public{\n        require(not_called_xxx13);\n        (bool success,)=msg.sender.call.value(1 ether)(\"\");\n        if( ! success ){\n            revert();\n        }\n        not_called_xxx13 = false;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) balances_xxx17;\nfunction withdrawFunds_xxx17 (uint256 _weiToWithdraw) public {\n        require(balances_xxx17[msg.sender] >= _weiToWithdraw);\n        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx17[msg.sender] -= _weiToWithdraw;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\naddress payable lastPlayer_xxx16;\n      uint jackpot_xxx16;\n\t  function buyTicket_xxx16() public{\n\t    if (!(lastPlayer_xxx16.send(jackpot_xxx16)))\n        revert();\n      lastPlayer_xxx16 = msg.sender;\n      jackpot_xxx16    = address(this).balance;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nuint256 counter_xxx28 =0;\nfunction callme_xxx28() public{\n        require(counter_xxx28<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx28 += 1;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nuint256 counter_xxx14 =0;\nfunction callme_xxx14() public{\n        require(counter_xxx14<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx14 += 1;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nmapping(address => uint) balances_xxx15;\n    function withdraw_balances_xxx15 () public {\n       if (msg.sender.send(balances_xxx15[msg.sender ]))\n          balances_xxx15[msg.sender] = 0;\n      }\n}\ncontract LedgeriumToken is ERC20 {\n  uint256 counter_xxx7 =0;\nfunction callme_xxx7() public{\n        require(counter_xxx7<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx7 += 1;\n    }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nmapping(address => uint) balances_xxx29;\n    function withdraw_balances_xxx29 () public {\n       if (msg.sender.send(balances_xxx29[msg.sender ]))\n          balances_xxx29[msg.sender] = 0;\n      }\n}",
    "type": "Re-entrancy"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx35() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  mapping (address => uint256) private _balances;\n  mapping(address => uint) public lockTime_xxx21;\nfunction increaseLockTime_xxx21(uint _secondsToIncrease) public {\n        lockTime_xxx21[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx21() public {\n        require(now > lockTime_xxx21[msg.sender]);    \n        uint transferValue_xxx21 = 10;           \n        msg.sender.transfer(transferValue_xxx21);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx20(uint8 p_xxx20) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx20;   \n}\n  uint256 private _totalSupply;\n  mapping(address => uint) balances_xxx34;\nfunction transfer_xxx34(address _to, uint _value) public returns (bool) {\n    require(balances_xxx34[msg.sender] - _value >= 0);  \n    balances_xxx34[msg.sender] -= _value;  \n    balances_xxx34[_to] += _value;  \n    return true;\n  }\n  string private _name;\n  mapping(address => uint) public lockTime_xxx1;\nfunction increaseLockTime_xxx1(uint _secondsToIncrease) public {\n        lockTime_xxx1[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_ovrflow1() public {\n        require(now > lockTime_xxx1[msg.sender]);    \n        uint transferValue_xxx1 = 10;           \n        msg.sender.transfer(transferValue_xxx1);\n    }\n  string private _symbol;\n  mapping(address => uint) balances_xxx2;\nfunction transfer_undrflow2(address _to, uint _value) public returns (bool) {\n    require(balances_xxx2[msg.sender] - _value >= 0);  \n    balances_xxx2[msg.sender] -= _value;  \n    balances_xxx2[_to] += _value;  \n    return true;\n  }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx7() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nmapping(address => uint) balances_xxx6;\nfunction transfer_xxx62(address _to, uint _value) public returns (bool) {\n    require(balances_xxx6[msg.sender] - _value >= 0);  \n    balances_xxx6[msg.sender] -= _value;  \n    balances_xxx6[_to] += _value;  \n    return true;\n  }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx40(uint8 p_xxx40) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx40;   \n}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx4(uint8 p_xxx4) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx4;   \n}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nmapping(address => uint) public lockTime_xxx5;\nfunction increaseLockTime_xxx5(uint _secondsToIncrease) public {\n        lockTime_xxx5[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx5() public {\n        require(now > lockTime_xxx5[msg.sender]);    \n        uint transferValue_xxx5 = 10;           \n        msg.sender.transfer(transferValue_xxx5);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx8(uint8 p_xxx8) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx8;   \n}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nmapping(address => uint) public lockTime_xxx9;\nfunction increaseLockTime_xxx9(uint _secondsToIncrease) public {\n        lockTime_xxx9[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx9() public {\n        require(now > lockTime_xxx9[msg.sender]);    \n        uint transferValue_xxx9 = 10;           \n        msg.sender.transfer(transferValue_xxx9);\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx11() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx39() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nmapping(address => uint) balances_xxx38;\nfunction transfer_xxx38(address _to, uint _value) public returns (bool) {\n    require(balances_xxx38[msg.sender] - _value >= 0);  \n    balances_xxx38[msg.sender] -= _value;  \n    balances_xxx38[_to] += _value;  \n    return true;\n  }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx10;\nfunction transfer_xxx10(address _to, uint _value) public returns (bool) {\n    require(balances_xxx10[msg.sender] - _value >= 0);  \n    balances_xxx10[msg.sender] -= _value;  \n    balances_xxx10[_to] += _value;  \n    return true;\n  }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12(uint8 p_xxx12) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx12;   \n}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) public lockTime_xxx13;\nfunction increaseLockTime_xxx13(uint _secondsToIncrease) public {\n        lockTime_xxx13[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx13() public {\n        require(now > lockTime_xxx13[msg.sender]);    \n        uint transferValue_xxx13 = 10;           \n        msg.sender.transfer(transferValue_xxx13);\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) public lockTime_xxx17;\nfunction increaseLockTime_xxx17(uint _secondsToIncrease) public {\n        lockTime_xxx17[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx17() public {\n        require(now > lockTime_xxx17[msg.sender]);    \n        uint transferValue_xxx17 = 10;           \n        msg.sender.transfer(transferValue_xxx17);\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16(uint8 p_xxx16) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx16;   \n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28(uint8 p_xxx28) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx28;   \n}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nmapping(address => uint) balances_xxx14;\nfunction transfer_xxx14(address _to, uint _value) public returns (bool) {\n    require(balances_xxx14[msg.sender] - _value >= 0);  \n    balances_xxx14[msg.sender] -= _value;  \n    balances_xxx14[_to] += _value;  \n    return true;\n  }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx3() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nmapping(address => uint) public lockTime_xxx29;\nfunction increaseLockTime_xxx29(uint _secondsToIncrease) public {\n        lockTime_xxx29[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx29() public {\n        require(now > lockTime_xxx29[msg.sender]);    \n        uint transferValue_xxx29 = 10;           \n        msg.sender.transfer(transferValue_xxx29);\n    }\n}",
    "type": "Overflow-Underflow"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  address winner_xxx2;\nfunction play_xxx2(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx2 = msg.sender;}}\n  mapping (address => uint256) private _balances;\n  address winner_xxx3;\nfunction play_xxx3(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx3 = msg.sender;}}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  address winner_xxx7;\nfunction play_xxx7(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx7 = msg.sender;}}\n  uint256 private _totalSupply;\n  address winner_xxx6;\nfunction play_xxx6(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx6 = msg.sender;}}\n  string private _name;\n  function xx_xxx40 () public payable {\n\tuint pastBlockTime_xxx40; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx40); \n        pastBlockTime_xxx40 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  string private _symbol;\n  function xx_xxx4 () public payable {\n\tuint pastBlockTime_xxx4; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx4); \n        pastBlockTime_xxx4 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx8 () public payable {\n\tuint pastBlockTime_xxx8; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx8); \n        pastBlockTime_xxx8 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx9() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\naddress winner_xxx11;\nfunction play_xxx11(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx11 = msg.sender;}}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\naddress winner_xxx39;\nfunction play_xxx39(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx39 = msg.sender;}}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress winner_xxx38;\nfunction play_xxx38(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx38 = msg.sender;}}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\naddress winner_xxx10;\nfunction play_xxx10(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx10 = msg.sender;}}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction xx_xxx12 () public payable {\n\tuint pastBlockTime_xxx12; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx12); \n        pastBlockTime_xxx12 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx13() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx17() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xx_xxx16 () public payable {\n\tuint pastBlockTime_xxx16; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx16); \n        pastBlockTime_xxx16 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx28 () public payable {\n\tuint pastBlockTime_xxx28; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx28); \n        pastBlockTime_xxx28 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\naddress winner_xxx14;\nfunction play_xxx14(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx14 = msg.sender;}}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress winner_xxx15;\nfunction play_xxx15(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx15 = msg.sender;}}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx29() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nuint256 xxv_xxx1 = block.timestamp;\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nuint256 xxv_xxx2 = block.timestamp;\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nuint256 xxv_xxx3 = block.timestamp;\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nuint256 xxv_xxx4 = block.timestamp;\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx5() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nuint256 xxv_xxx5 = block.timestamp;\n}",
    "type": "Timestamp-Dependency"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  address payable winner_xxx35;\nfunction play_xxx35(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx35 = msg.sender;\n        }\n    }\nfunction getReward_xxx35() payable public{\n       winner_xxx35.transfer(msg.value);\n    }\n  mapping (address => uint256) private _balances;\n  address payable winner_xxx21;\nfunction play_xxx21(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx21 = msg.sender;\n        }\n    }\nfunction getReward_xxx21() payable public{\n       winner_xxx21.transfer(msg.value);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  bool claimed_xxx20 = false;\naddress payable owner_xxx20;\nuint256 reward_xxx20;\nfunction setReward_xxx20() public payable {\n        require (!claimed_xxx20);\n        require(msg.sender == owner_xxx20);\n        owner_xxx20.transfer(reward_xxx20);\n        reward_xxx20 = msg.value;\n    }\n    function claimReward_xxx20(uint256 submission) public {\n        require (!claimed_xxx20);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx20);\n        claimed_xxx20 = true;\n    }\n  uint256 private _totalSupply;\n  bool claimed_xxx34 = false;\naddress payable owner_xxx34;\nuint256 reward_xxx34;\nfunction setReward_xxx34() public payable {\n        require (!claimed_xxx34);\n        require(msg.sender == owner_xxx34);\n        owner_xxx34.transfer(reward_xxx34);\n        reward_xxx34 = msg.value;\n    }\n    function claimReward_xxx34(uint256 submission) public {\n        require (!claimed_xxx34);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx34);\n        claimed_xxx34 = true;\n    }\n  string private _name;\n  address payable winner_xxx1;\nfunction play_xxx1(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx1 = msg.sender;\n        }\n    }\nfunction getReward_xxx1() payable public{\n       winner_xxx1.transfer(msg.value);\n    }\n  string private _symbol;\n  bool claimed_xxx2 = false;\naddress payable owner_xxx2;\nuint256 reward_xxx2;\nfunction setReward_xxx2() public payable {\n        require (!claimed_xxx2);\n        require(msg.sender == owner_xxx2);\n        owner_xxx2.transfer(reward_xxx2);\n        reward_xxx2 = msg.value;\n    }\n    function claimReward_xxx2(uint256 submission) public {\n        require (!claimed_xxx2);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx2);\n        claimed_xxx2 = true;\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\naddress payable winner_xxx7;\nfunction play_xxx7(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx7 = msg.sender;\n        }\n    }\nfunction getReward_xxx7() payable public{\n       winner_xxx7.transfer(msg.value);\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nbool claimed_xxx6 = false;\naddress payable owner_xxx6;\nuint256 reward_xxx6;\nfunction setReward_xxx6() public payable {\n        require (!claimed_xxx6);\n        require(msg.sender == owner_xxx6);\n        owner_xxx6.transfer(reward_xxx6);\n        reward_xxx6 = msg.value;\n    }\n    function claimReward_xxx6(uint256 submission) public {\n        require (!claimed_xxx6);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx6);\n        claimed_xxx6 = true;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nbool claimed_xxx40 = false;\naddress payable owner_xxx40;\nuint256 reward_xxx40;\nfunction setReward_xxx40() public payable {\n        require (!claimed_xxx40);\n        require(msg.sender == owner_xxx40);\n        owner_xxx40.transfer(reward_xxx40);\n        reward_xxx40 = msg.value;\n    }\n    function claimReward_xxx40(uint256 submission) public {\n        require (!claimed_xxx40);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx40);\n        claimed_xxx40 = true;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nbool claimed_xxx4 = false;\naddress payable owner_xxx4;\nuint256 reward_xxx4;\nfunction setReward_xxx4() public payable {\n        require (!claimed_xxx4);\n        require(msg.sender == owner_xxx4);\n        owner_xxx4.transfer(reward_xxx4);\n        reward_xxx4 = msg.value;\n    }\n    function claimReward_xxx4(uint256 submission) public {\n        require (!claimed_xxx4);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx4);\n        claimed_xxx4 = true;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress payable winner_xxx5;\nfunction play_xxx5(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx5 = msg.sender;\n        }\n    }\nfunction getReward_xxx5() payable public{\n       winner_xxx5.transfer(msg.value);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool claimed_xxx8 = false;\naddress payable owner_xxx8;\nuint256 reward_xxx8;\nfunction setReward_xxx8() public payable {\n        require (!claimed_xxx8);\n        require(msg.sender == owner_xxx8);\n        owner_xxx8.transfer(reward_xxx8);\n        reward_xxx8 = msg.value;\n    }\n    function claimReward_xxx8(uint256 submission) public {\n        require (!claimed_xxx8);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx8);\n        claimed_xxx8 = true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress payable winner_xxx9;\nfunction play_xxx9(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx9 = msg.sender;\n        }\n    }\nfunction getReward_xxx9() payable public{\n       winner_xxx9.transfer(msg.value);\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\naddress payable winner_xxx11;\nfunction play_xxx11(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx11 = msg.sender;\n        }\n    }\nfunction getReward_xxx11() payable public{\n       winner_xxx11.transfer(msg.value);\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\naddress payable winner_xxx39;\nfunction play_xxx39(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx39 = msg.sender;\n        }\n    }\nfunction getReward_xxx39() payable public{\n       winner_xxx39.transfer(msg.value);\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nbool claimed_xxx38 = false;\naddress payable owner_xxx38;\nuint256 reward_xxx38;\nfunction setReward_xxx38() public payable {\n        require (!claimed_xxx38);\n        require(msg.sender == owner_xxx38);\n        owner_xxx38.transfer(reward_xxx38);\n        reward_xxx38 = msg.value;\n    }\n    function claimReward_xxx38(uint256 submission) public {\n        require (!claimed_xxx38);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx38);\n        claimed_xxx38 = true;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nbool claimed_xxx10 = false;\naddress payable owner_xxx10;\nuint256 reward_xxx10;\nfunction setReward_xxx10() public payable {\n        require (!claimed_xxx10);\n        require(msg.sender == owner_xxx10);\n        owner_xxx10.transfer(reward_xxx10);\n        reward_xxx10 = msg.value;\n    }\n    function claimReward_xxx10(uint256 submission) public {\n        require (!claimed_xxx10);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx10);\n        claimed_xxx10 = true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nbool claimed_xxx12 = false;\naddress payable owner_xxx12;\nuint256 reward_xxx12;\nfunction setReward_xxx12() public payable {\n        require (!claimed_xxx12);\n        require(msg.sender == owner_xxx12);\n        owner_xxx12.transfer(reward_xxx12);\n        reward_xxx12 = msg.value;\n    }\n    function claimReward_xxx12(uint256 submission) public {\n        require (!claimed_xxx12);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx12);\n        claimed_xxx12 = true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress payable winner_xxx13;\nfunction play_xxx13(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx13 = msg.sender;\n        }\n    }\nfunction getReward_xxx13() payable public{\n       winner_xxx13.transfer(msg.value);\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress payable winner_xxx17;\nfunction play_xxx17(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx17 = msg.sender;\n        }\n    }\nfunction getReward_xxx17() payable public{\n       winner_xxx17.transfer(msg.value);\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nbool claimed_xxx16 = false;\naddress payable owner_xxx16;\nuint256 reward_xxx16;\nfunction setReward_xxx16() public payable {\n        require (!claimed_xxx16);\n        require(msg.sender == owner_xxx16);\n        owner_xxx16.transfer(reward_xxx16);\n        reward_xxx16 = msg.value;\n    }\n    function claimReward_xxx16(uint256 submission) public {\n        require (!claimed_xxx16);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx16);\n        claimed_xxx16 = true;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nbool claimed_xxx28 = false;\naddress payable owner_xxx28;\nuint256 reward_xxx28;\nfunction setReward_xxx28() public payable {\n        require (!claimed_xxx28);\n        require(msg.sender == owner_xxx28);\n        owner_xxx28.transfer(reward_xxx28);\n        reward_xxx28 = msg.value;\n    }\n    function claimReward_xxx28(uint256 submission) public {\n        require (!claimed_xxx28);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx28);\n        claimed_xxx28 = true;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nbool claimed_xxx14 = false;\naddress payable owner_xxx14;\nuint256 reward_xxx14;\nfunction setReward_xxx14() public payable {\n        require (!claimed_xxx14);\n        require(msg.sender == owner_xxx14);\n        owner_xxx14.transfer(reward_xxx14);\n        reward_xxx14 = msg.value;\n    }\n    function claimReward_xxx14(uint256 submission) public {\n        require (!claimed_xxx14);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx14);\n        claimed_xxx14 = true;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\naddress payable winner_xxx15;\nfunction play_xxx15(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx15 = msg.sender;\n        }\n    }\nfunction getReward_xxx15() payable public{\n       winner_xxx15.transfer(msg.value);\n    }\n}\ncontract LedgeriumToken is ERC20 {\n  address payable winner_xxx3;\nfunction play_xxx3(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx3 = msg.sender;\n        }\n    }\nfunction getReward_xxx3() payable public{\n       winner_xxx3.transfer(msg.value);\n    }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\naddress payable winner_xxx29;\nfunction play_xxx29(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx29 = msg.sender;\n        }\n    }\nfunction getReward_xxx29() payable public{\n       winner_xxx29.transfer(msg.value);\n    }\n}",
    "type": "TOD"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function transferTo_xxx35(address to, uint amount,address owner_xxx35) public {\n  require(tx.origin == owner_xxx35);\n  to.call.value(amount);\n}\n  mapping (address => uint256) private _balances;\n  function sendto_xxx21(address payable receiver, uint amount,address owner_xxx21) public {\n\trequire (tx.origin == owner_xxx21);\n\treceiver.transfer(amount);\n}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx20(address owner_xxx20) public{\n        require(tx.origin == owner_xxx20);\n    }\n  uint256 private _totalSupply;\n  function withdrawAll_xxx34(address payable _recipient,address owner_xxx34) public {\n        require(tx.origin == owner_xxx34);\n        _recipient.transfer(address(this).balance);\n    }\n  string private _name;\n  function sendto_xxx1(address payable receiver, uint amount,address owner_xxx1) public {\n\trequire (tx.origin == owner_xxx1);\n\treceiver.transfer(amount);\n}\n  string private _symbol;\n  function withdrawAll_xxx2(address payable _recipient,address owner_xxx2) public {\n        require(tx.origin == owner_xxx2);\n        _recipient.transfer(address(this).balance);\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction transferTo_xxx7(address to, uint amount,address owner_xxx7) public {\n  require(tx.origin == owner_xxx7);\n  to.call.value(amount);\n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction withdrawAll_xxx6(address payable _recipient,address owner_xxx6) public {\n        require(tx.origin == owner_xxx6);\n        _recipient.transfer(address(this).balance);\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx40(address owner_xxx40) public{\n        require(tx.origin == owner_xxx40);\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx4(address owner_xxx4) public{\n        require(tx.origin == owner_xxx4);\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction sendto_xxx5(address payable receiver, uint amount,address owner_xxx5) public {\n\trequire (tx.origin == owner_xxx5);\n\treceiver.transfer(amount);\n}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx8(address owner_xxx8) public{\n        require(tx.origin == owner_xxx8);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction sendto_xxx9(address payable receiver, uint amount,address owner_xxx9) public {\n\trequire (tx.origin == owner_xxx9);\n\treceiver.transfer(amount);\n}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction transferTo_xxx11(address to, uint amount,address owner_xxx11) public {\n  require(tx.origin == owner_xxx11);\n  to.call.value(amount);\n}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction transferTo_xxx39(address to, uint amount,address owner_xxx39) public {\n  require(tx.origin == owner_xxx39);\n  to.call.value(amount);\n}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction withdrawAll_xxx38(address payable _recipient,address owner_xxx38) public {\n        require(tx.origin == owner_xxx38);\n        _recipient.transfer(address(this).balance);\n}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction withdrawAll_xxx10(address payable _recipient,address owner_xxx10) public {\n        require(tx.origin == owner_xxx10);\n        _recipient.transfer(address(this).balance);\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12(address owner_xxx12) public{\n        require(tx.origin == owner_xxx12);\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction sendto_xxx13(address payable receiver, uint amount,address owner_xxx13) public {\n\trequire (tx.origin == owner_xxx13);\n\treceiver.transfer(amount);\n}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction sendto_xxx17(address payable receiver, uint amount,address owner_xxx17) public {\n\trequire (tx.origin == owner_xxx17);\n\treceiver.transfer(amount);\n}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16(address owner_xxx16) public{\n        require(tx.origin == owner_xxx16);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28(  address owner_xxx28) public{\n        require(tx.origin == owner_xxx28);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction withdrawAll_xxx14(address payable _recipient,address owner_xxx14) public {\n        require(tx.origin == owner_xxx14);\n        _recipient.transfer(address(this).balance);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction transferTo_xxx15(address to, uint amount,address owner_xxx15) public {\n  require(tx.origin == owner_xxx15);\n  to.call.value(amount);\n}\n}\ncontract LedgeriumToken is ERC20 {\n  function transferTo_xxx3(address to, uint amount,address owner_xxx3) public {\n  require(tx.origin == owner_xxx3);\n  to.call.value(amount);\n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction sendto_xxx29(address payable receiver, uint amount,address owner_xxx29) public {\n\trequire (tx.origin == owner_xxx29);\n\treceiver.transfer(amount);\n}\n}",
    "type": "tx.origin"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx27() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (address => uint256) private _balances;\n  function xx_xxx32() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx26() payable public{\n      msg.sender.transfer(1 ether);}\n  uint256 private _totalSupply;\n  function xx_xxx22() payable public{\n      msg.sender.transfer(1 ether);}\n  string private _name;\n  function xx_xxx23() payable public{\n      msg.sender.transfer(1 ether);}\n  string private _symbol;\n  function xx_xxx21() payable public{\n      msg.sender.transfer(1 ether);}\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx1() payable public{\n      msg.sender.transfer(1 ether);}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx2() payable public{\n      msg.sender.transfer(1 ether);}\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx3() payable public{\n      msg.sender.transfer(1 ether);}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx7() payable public{\n      msg.sender.transfer(1 ether);}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction xx_xxx6() payable public{\n      msg.sender.transfer(1 ether);}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx4() payable public{\n      msg.sender.transfer(1 ether);}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction xx_xxx5() payable public{\n      msg.sender.transfer(1 ether);}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx8() payable public{\n      msg.sender.transfer(1 ether);}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx9() payable public{\n      msg.sender.transfer(1 ether);}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xx_xxx11() payable public{\n      msg.sender.transfer(1 ether);}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx10() payable public{\n      msg.sender.transfer(1 ether);}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12() payable public{\n      msg.sender.transfer(1 ether);}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx13() payable public{\n      msg.sender.transfer(1 ether);}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx17() payable public{\n      msg.sender.transfer(1 ether);}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16() payable public{\n      msg.sender.transfer(1 ether);}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction xx_xxx14() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15() payable public{\n      msg.sender.transfer(1 ether);}\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx20() payable public{\n      msg.sender.transfer(1 ether);}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction xx_xxx29() payable public{\n      msg.sender.transfer(1 ether);}\n}",
    "type": "Unchecked-Send"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xxsend_xxx2(address payable callee) public {\n    callee.send(5 ether);\n  }\n  mapping (address => uint256) private _balances;\n  function xx_xxx3(address payable addr) public\n      {addr.send (42 ether); }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  bool public payedOut_xxx45 = false;\nfunction withdrawLeftOver_xxx45() public {\n        require(payedOut_xxx45);\n        msg.sender.send(address(this).balance);\n    }\n  uint256 private _totalSupply;\n  function withdrawBal_xxx41 () public{\n\tuint64 Balances_xxx41 = 0;\n\tmsg.sender.send(Balances_xxx41);}\n  string private _name;\n  function xx_xxx7() public{\naddress payable addr_xxx7;\nif (!addr_xxx7.send (10 ether) || 1==1)\n\t{revert();}\n}\n  string private _symbol;\n  function xx_xxx6() public{\nuint receivers_xxx6;\naddress payable addr_xxx6;\nif (!addr_xxx6.send(42 ether))\n\t{receivers_xxx6 +=1;}\nelse\n\t{revert();}\n}\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xxExternalCall_xxx4 () public\n{  address payable addr_xxx4;\n   if (! addr_xxx4.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx42() public{\nuint receivers_xxx42;\naddress payable addr_xxx42;\nif (!addr_xxx42.send(42 ether))\n\t{receivers_xxx42 +=1;}\nelse\n\t{revert();}\n}\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx43() public{\naddress payable addr_xxx43;\nif (!addr_xxx43.send (10 ether) || 1==1)\n\t{revert();}\n}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction withdrawBal_xxx5 () public{\n\tuint64 Balances_xxx5 = 0;\n\tmsg.sender.send(Balances_xxx5);}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nbool public payedOut_xxx8 = false;\naddress payable public winner_xxx8;\nuint public winAmount_xxx8;\nfunction sendToWinner_xxx8() public {\n        require(!payedOut_xxx8);\n        winner_xxx8.send(winAmount_xxx8);\n        payedOut_xxx8 = true;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool public payedOut_xxx9 = false;\nfunction withdrawLeftOver_xxx9() public {\n        require(payedOut_xxx9);\n        msg.sender.send(address(this).balance);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction my_func_uncheck48(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction my_func_xxx11(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx39(address payable addr) public\n      {addr.send (4 ether); }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xxsend_xxx38(address payable callee) public {\n    callee.send(5 ether);\n  }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction cash_xxx10(uint roundIndex, uint subpotIndex,address payable winner_xxx10) public{\n        uint64 subpot_xxx10 = 10 ether;\n        winner_xxx10.send(subpot_xxx10);  \n        subpot_xxx10= 0;\n}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction my_func_uncheck12(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction callxx_xxx13(address callee) public {\n    callee.call.value(1 ether);\n  }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction withdrawBal_xxx17 () public{\n\tuint64 Balances_xxx17 = 0;\n\tmsg.sender.send(Balances_xxx17);}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xxExternalCall_xxx16 () public\n{  address payable addr_xxx16;\n   if (! addr_xxx16.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xxExternalCall_xxx28 () public\n{  address payable addr_xxx28;\n   if (! addr_xxx28.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction xxsend_xxx14(address payable callee) public {\n    callee.send(5 ether);\n  }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15(address payable addr) public\n      {addr.send (42 ether); }\n}\ncontract LedgeriumToken is ERC20 {\n  function xxExternalCall_xxx40 () public\n{  address payable addr_xxx40;\n   if (! addr_xxx40.send (2 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction withdrawBal_xxx29 () public{\n\tuint Balances_xxx29 = 0;\n\tmsg.sender.send(Balances_xxx29);}\n}",
    "type": "Unhandled-Exceptions"
  },
  {
    "contract": "pragma solidity ^0.4.16;\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n  mapping(address => uint256) balances;\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n  mapping (address => mapping (address => uint256)) internal allowed;\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\ncontract Ownable {\n  address public owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  function Ownable() {\n    owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n  bool public paused = false;\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\ncontract PausableToken is StandardToken, Pausable {\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\ncontract BecToken is PausableToken {\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    \n    }\n    function () {\n        revert();\n    }\n}",
    "type": "Overflow-Underflow"
  },
  {
    "contract": "pragma solidity ^0.4.19;\ncontract ReentrancyDAO {\n    mapping (address => uint) credit;\n    uint balance;\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
    "type": "Re-entrancy"
  },
  {
    "contract": "pragma solidity ^0.4.25;\ncontract TimedCrowdsale {\n  function isSaleFinished() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
    "type": "Timestamp-Dependency"
  },
  {
    "contract": "pragma solidity ^0.4.22;\ncontract FindThisHash {\n    bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n    constructor() public payable {} \n    function solve(string solution) public {\n        require(hash == sha3(solution));\n        msg.sender.transfer(1000 ether);\n    }\n}",
    "type": "TOD"
  },
  {
    "contract": "pragma solidity ^0.4.24;\ncontract Missing{\n    address private owner;\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    function missing()\n        public\n    {\n        owner = msg.sender;\n    }\n    function () payable {}\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}",
    "type": "tx.origin"
  },
  {
    "contract": "pragma solidity ^0.4.11; \ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n    address public owner;\n    modifier onlyOwner { if (msg.sender == owner) _; }\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        _dst.call.value(_value)(_data);\n    }\n}\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}\ncontract TokenSender is Owned {\n    Token public token; \n    uint public totalToDistribute;\n    uint public next;\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n    Transfer[] public transfers;\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n    function fill(uint[] data) onlyOwner {\n        if (next>0) throw;\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n        uint mNext = next;\n        next = transfers.length;\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n        next = mNext;\n    }\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n}",
    "type": "Unchecked-Send"
  }
]