[
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\ncontract LedgeriumToken is ERC20 {\n    uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n}",
    "type": "correct"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  bool not_called_xxx20 = true;\nfunction xx_xxx20() public{\n        require(not_called_xxx20);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx20 = false;\n    }\n  mapping (address => uint256) private _balances;\n  bool not_called_xxx34 = true;\nfunction xx_xxx34() public{\n        require(not_called_xxx34);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx34 = false;\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  mapping(address => uint) balances_xxx1;\n    function withdraw_balances_xxx1 () public {\n       (bool success,) =msg.sender.call.value(balances_xxx1[msg.sender ])(\"\");\n       if (success)\n          balances_xxx1[msg.sender] = 0;\n      }\n  uint256 private _totalSupply;\n  address payable lastPlayer_xxx2;\n      uint jackpot_xxx2;\n\t  function buyTicket_xxx2() public{\n\t    if (!(lastPlayer_xxx2.send(jackpot_xxx2)))\n        revert();\n      lastPlayer_xxx2 = msg.sender;\n      jackpot_xxx2    = address(this).balance;\n    }\n  string private _name;\n  mapping(address => uint) balances_xxx3;\nfunction withdrawFunds_xxx3 (uint256 _weiToWithdraw) public {\n        require(balances_xxx3[msg.sender] >= _weiToWithdraw);\n\t(bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx3[msg.sender] -= _weiToWithdraw;\n    }\n  string private _symbol;\n  bool not_called_xxx41 = true;\nfunction xx_xxx41() public{\n        require(not_called_xxx41);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx41 = false;\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nbool not_called_xxx6 = true;\nfunction xx_xxx6() public{\n        require(not_called_xxx6);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx6 = false;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nmapping(address => uint) userBalance_xxx40;\nfunction withdrawBalance_xxx40() public{\n        (bool success,)=msg.sender.call.value(userBalance_xxx40[msg.sender])(\"\");\n        if( ! success ){\n            revert();\n        }\n        userBalance_xxx40[msg.sender] = 0;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nmapping(address => uint) redeemableEther_xxx4;\nfunction claimReward_xxx4() public {        \n        require(redeemableEther_xxx4[msg.sender] > 0);\n        uint transferValue_xxx4 = redeemableEther_xxx4[msg.sender];\n        msg.sender.transfer(transferValue_xxx4);   \n        redeemableEther_xxx4[msg.sender] = 0;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nuint256 counter_xxx42 =0;\nfunction callme_xxx42() public{\n        require(counter_xxx42<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx42 += 1;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nmapping(address => uint) userBalance_xxx5;\nfunction withdrawBalance_xxx5() public{\n        if( ! (msg.sender.send(userBalance_xxx5[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx5[msg.sender] = 0;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nmapping(address => uint) balances_xxx8;\n    function withdraw_balances_xxx8 () public {\n       (bool success,) = msg.sender.call.value(balances_xxx8[msg.sender ])(\"\");\n       if (success)\n          balances_xxx8[msg.sender] = 0;\n      }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress payable lastPlayer_xxx9;\n      uint jackpot_xxx9;\n\t  function buyTicket_xxx9() public{\n\t    (bool success,) = lastPlayer_xxx9.call.value(jackpot_xxx9)(\"\");\n\t    if (!success)\n\t        revert();\n      lastPlayer_xxx9 = msg.sender;\n      jackpot_xxx9    = address(this).balance;\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nmapping(address => uint) redeemableEther_xxx11;\nfunction claimReward_xxx11() public {        \n        require(redeemableEther_xxx11[msg.sender] > 0);\n        uint transferValue_xxx11 = redeemableEther_xxx11[msg.sender];\n        msg.sender.transfer(transferValue_xxx11);   \n        redeemableEther_xxx11[msg.sender] = 0;\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nmapping(address => uint) redeemableEther_xxx39;\nfunction claimReward_xxx39() public {        \n        require(redeemableEther_xxx39[msg.sender] > 0);\n        uint transferValue_xxx39 = redeemableEther_xxx39[msg.sender];\n        msg.sender.transfer(transferValue_xxx39);   \n        redeemableEther_xxx39[msg.sender] = 0;\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nmapping(address => uint) balances_xxx38;\nfunction withdrawFunds_xxx38 (uint256 _weiToWithdraw) public {\n        require(balances_xxx38[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx38[msg.sender] -= _weiToWithdraw;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx10;\nfunction withdrawFunds_xxx10 (uint256 _weiToWithdraw) public {\n        require(balances_xxx10[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx10[msg.sender] -= _weiToWithdraw;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nmapping(address => uint) userBalance_xxx12;\nfunction withdrawBalance_xxx12() public{\n        if( ! (msg.sender.send(userBalance_xxx12[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx12[msg.sender] = 0;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nbool not_called_xxx13 = true;\nfunction xx_xxx13() public{\n        require(not_called_xxx13);\n        (bool success,)=msg.sender.call.value(1 ether)(\"\");\n        if( ! success ){\n            revert();\n        }\n        not_called_xxx13 = false;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) balances_xxx17;\nfunction withdrawFunds_xxx17 (uint256 _weiToWithdraw) public {\n        require(balances_xxx17[msg.sender] >= _weiToWithdraw);\n        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx17[msg.sender] -= _weiToWithdraw;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\naddress payable lastPlayer_xxx16;\n      uint jackpot_xxx16;\n\t  function buyTicket_xxx16() public{\n\t    if (!(lastPlayer_xxx16.send(jackpot_xxx16)))\n        revert();\n      lastPlayer_xxx16 = msg.sender;\n      jackpot_xxx16    = address(this).balance;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nuint256 counter_xxx28 =0;\nfunction callme_xxx28() public{\n        require(counter_xxx28<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx28 += 1;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nuint256 counter_xxx14 =0;\nfunction callme_xxx14() public{\n        require(counter_xxx14<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx14 += 1;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nmapping(address => uint) balances_xxx15;\n    function withdraw_balances_xxx15 () public {\n       if (msg.sender.send(balances_xxx15[msg.sender ]))\n          balances_xxx15[msg.sender] = 0;\n      }\n}\ncontract LedgeriumToken is ERC20 {\n  uint256 counter_xxx7 =0;\nfunction callme_xxx7() public{\n        require(counter_xxx7<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx7 += 1;\n    }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nmapping(address => uint) balances_xxx29;\n    function withdraw_balances_xxx29 () public {\n       if (msg.sender.send(balances_xxx29[msg.sender ]))\n          balances_xxx29[msg.sender] = 0;\n      }\n}",
    "type": "Re-entrancy"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx35() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  mapping (address => uint256) private _balances;\n  mapping(address => uint) public lockTime_xxx21;\nfunction increaseLockTime_xxx21(uint _secondsToIncrease) public {\n        lockTime_xxx21[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx21() public {\n        require(now > lockTime_xxx21[msg.sender]);    \n        uint transferValue_xxx21 = 10;           \n        msg.sender.transfer(transferValue_xxx21);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx20(uint8 p_xxx20) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx20;   \n}\n  uint256 private _totalSupply;\n  mapping(address => uint) balances_xxx34;\nfunction transfer_xxx34(address _to, uint _value) public returns (bool) {\n    require(balances_xxx34[msg.sender] - _value >= 0);  \n    balances_xxx34[msg.sender] -= _value;  \n    balances_xxx34[_to] += _value;  \n    return true;\n  }\n  string private _name;\n  mapping(address => uint) public lockTime_xxx1;\nfunction increaseLockTime_xxx1(uint _secondsToIncrease) public {\n        lockTime_xxx1[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_ovrflow1() public {\n        require(now > lockTime_xxx1[msg.sender]);    \n        uint transferValue_xxx1 = 10;           \n        msg.sender.transfer(transferValue_xxx1);\n    }\n  string private _symbol;\n  mapping(address => uint) balances_xxx2;\nfunction transfer_undrflow2(address _to, uint _value) public returns (bool) {\n    require(balances_xxx2[msg.sender] - _value >= 0);  \n    balances_xxx2[msg.sender] -= _value;  \n    balances_xxx2[_to] += _value;  \n    return true;\n  }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx7() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nmapping(address => uint) balances_xxx6;\nfunction transfer_xxx62(address _to, uint _value) public returns (bool) {\n    require(balances_xxx6[msg.sender] - _value >= 0);  \n    balances_xxx6[msg.sender] -= _value;  \n    balances_xxx6[_to] += _value;  \n    return true;\n  }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx40(uint8 p_xxx40) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx40;   \n}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx4(uint8 p_xxx4) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx4;   \n}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nmapping(address => uint) public lockTime_xxx5;\nfunction increaseLockTime_xxx5(uint _secondsToIncrease) public {\n        lockTime_xxx5[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx5() public {\n        require(now > lockTime_xxx5[msg.sender]);    \n        uint transferValue_xxx5 = 10;           \n        msg.sender.transfer(transferValue_xxx5);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx8(uint8 p_xxx8) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx8;   \n}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nmapping(address => uint) public lockTime_xxx9;\nfunction increaseLockTime_xxx9(uint _secondsToIncrease) public {\n        lockTime_xxx9[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx9() public {\n        require(now > lockTime_xxx9[msg.sender]);    \n        uint transferValue_xxx9 = 10;           \n        msg.sender.transfer(transferValue_xxx9);\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx11() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx39() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nmapping(address => uint) balances_xxx38;\nfunction transfer_xxx38(address _to, uint _value) public returns (bool) {\n    require(balances_xxx38[msg.sender] - _value >= 0);  \n    balances_xxx38[msg.sender] -= _value;  \n    balances_xxx38[_to] += _value;  \n    return true;\n  }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx10;\nfunction transfer_xxx10(address _to, uint _value) public returns (bool) {\n    require(balances_xxx10[msg.sender] - _value >= 0);  \n    balances_xxx10[msg.sender] -= _value;  \n    balances_xxx10[_to] += _value;  \n    return true;\n  }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12(uint8 p_xxx12) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx12;   \n}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) public lockTime_xxx13;\nfunction increaseLockTime_xxx13(uint _secondsToIncrease) public {\n        lockTime_xxx13[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx13() public {\n        require(now > lockTime_xxx13[msg.sender]);    \n        uint transferValue_xxx13 = 10;           \n        msg.sender.transfer(transferValue_xxx13);\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) public lockTime_xxx17;\nfunction increaseLockTime_xxx17(uint _secondsToIncrease) public {\n        lockTime_xxx17[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx17() public {\n        require(now > lockTime_xxx17[msg.sender]);    \n        uint transferValue_xxx17 = 10;           \n        msg.sender.transfer(transferValue_xxx17);\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16(uint8 p_xxx16) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx16;   \n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28(uint8 p_xxx28) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx28;   \n}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nmapping(address => uint) balances_xxx14;\nfunction transfer_xxx14(address _to, uint _value) public returns (bool) {\n    require(balances_xxx14[msg.sender] - _value >= 0);  \n    balances_xxx14[msg.sender] -= _value;  \n    balances_xxx14[_to] += _value;  \n    return true;\n  }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx3() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nmapping(address => uint) public lockTime_xxx29;\nfunction increaseLockTime_xxx29(uint _secondsToIncrease) public {\n        lockTime_xxx29[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx29() public {\n        require(now > lockTime_xxx29[msg.sender]);    \n        uint transferValue_xxx29 = 10;           \n        msg.sender.transfer(transferValue_xxx29);\n    }\n}",
    "type": "Overflow-Underflow"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  address winner_xxx2;\nfunction play_xxx2(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx2 = msg.sender;}}\n  mapping (address => uint256) private _balances;\n  address winner_xxx3;\nfunction play_xxx3(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx3 = msg.sender;}}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  address winner_xxx7;\nfunction play_xxx7(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx7 = msg.sender;}}\n  uint256 private _totalSupply;\n  address winner_xxx6;\nfunction play_xxx6(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx6 = msg.sender;}}\n  string private _name;\n  function xx_xxx40 () public payable {\n\tuint pastBlockTime_xxx40; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx40); \n        pastBlockTime_xxx40 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  string private _symbol;\n  function xx_xxx4 () public payable {\n\tuint pastBlockTime_xxx4; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx4); \n        pastBlockTime_xxx4 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx8 () public payable {\n\tuint pastBlockTime_xxx8; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx8); \n        pastBlockTime_xxx8 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx9() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\naddress winner_xxx11;\nfunction play_xxx11(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx11 = msg.sender;}}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\naddress winner_xxx39;\nfunction play_xxx39(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx39 = msg.sender;}}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress winner_xxx38;\nfunction play_xxx38(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx38 = msg.sender;}}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\naddress winner_xxx10;\nfunction play_xxx10(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx10 = msg.sender;}}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction xx_xxx12 () public payable {\n\tuint pastBlockTime_xxx12; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx12); \n        pastBlockTime_xxx12 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx13() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx17() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xx_xxx16 () public payable {\n\tuint pastBlockTime_xxx16; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx16); \n        pastBlockTime_xxx16 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx28 () public payable {\n\tuint pastBlockTime_xxx28; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx28); \n        pastBlockTime_xxx28 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\naddress winner_xxx14;\nfunction play_xxx14(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx14 = msg.sender;}}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress winner_xxx15;\nfunction play_xxx15(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx15 = msg.sender;}}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx29() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nuint256 xxv_xxx1 = block.timestamp;\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nuint256 xxv_xxx2 = block.timestamp;\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nuint256 xxv_xxx3 = block.timestamp;\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nuint256 xxv_xxx4 = block.timestamp;\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx5() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nuint256 xxv_xxx5 = block.timestamp;\n}",
    "type": "Timestamp-Dependency"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  address payable winner_xxx35;\nfunction play_xxx35(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx35 = msg.sender;\n        }\n    }\nfunction getReward_xxx35() payable public{\n       winner_xxx35.transfer(msg.value);\n    }\n  mapping (address => uint256) private _balances;\n  address payable winner_xxx21;\nfunction play_xxx21(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx21 = msg.sender;\n        }\n    }\nfunction getReward_xxx21() payable public{\n       winner_xxx21.transfer(msg.value);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  bool claimed_xxx20 = false;\naddress payable owner_xxx20;\nuint256 reward_xxx20;\nfunction setReward_xxx20() public payable {\n        require (!claimed_xxx20);\n        require(msg.sender == owner_xxx20);\n        owner_xxx20.transfer(reward_xxx20);\n        reward_xxx20 = msg.value;\n    }\n    function claimReward_xxx20(uint256 submission) public {\n        require (!claimed_xxx20);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx20);\n        claimed_xxx20 = true;\n    }\n  uint256 private _totalSupply;\n  bool claimed_xxx34 = false;\naddress payable owner_xxx34;\nuint256 reward_xxx34;\nfunction setReward_xxx34() public payable {\n        require (!claimed_xxx34);\n        require(msg.sender == owner_xxx34);\n        owner_xxx34.transfer(reward_xxx34);\n        reward_xxx34 = msg.value;\n    }\n    function claimReward_xxx34(uint256 submission) public {\n        require (!claimed_xxx34);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx34);\n        claimed_xxx34 = true;\n    }\n  string private _name;\n  address payable winner_xxx1;\nfunction play_xxx1(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx1 = msg.sender;\n        }\n    }\nfunction getReward_xxx1() payable public{\n       winner_xxx1.transfer(msg.value);\n    }\n  string private _symbol;\n  bool claimed_xxx2 = false;\naddress payable owner_xxx2;\nuint256 reward_xxx2;\nfunction setReward_xxx2() public payable {\n        require (!claimed_xxx2);\n        require(msg.sender == owner_xxx2);\n        owner_xxx2.transfer(reward_xxx2);\n        reward_xxx2 = msg.value;\n    }\n    function claimReward_xxx2(uint256 submission) public {\n        require (!claimed_xxx2);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx2);\n        claimed_xxx2 = true;\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\naddress payable winner_xxx7;\nfunction play_xxx7(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx7 = msg.sender;\n        }\n    }\nfunction getReward_xxx7() payable public{\n       winner_xxx7.transfer(msg.value);\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\nbool claimed_xxx6 = false;\naddress payable owner_xxx6;\nuint256 reward_xxx6;\nfunction setReward_xxx6() public payable {\n        require (!claimed_xxx6);\n        require(msg.sender == owner_xxx6);\n        owner_xxx6.transfer(reward_xxx6);\n        reward_xxx6 = msg.value;\n    }\n    function claimReward_xxx6(uint256 submission) public {\n        require (!claimed_xxx6);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx6);\n        claimed_xxx6 = true;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nbool claimed_xxx40 = false;\naddress payable owner_xxx40;\nuint256 reward_xxx40;\nfunction setReward_xxx40() public payable {\n        require (!claimed_xxx40);\n        require(msg.sender == owner_xxx40);\n        owner_xxx40.transfer(reward_xxx40);\n        reward_xxx40 = msg.value;\n    }\n    function claimReward_xxx40(uint256 submission) public {\n        require (!claimed_xxx40);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx40);\n        claimed_xxx40 = true;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nbool claimed_xxx4 = false;\naddress payable owner_xxx4;\nuint256 reward_xxx4;\nfunction setReward_xxx4() public payable {\n        require (!claimed_xxx4);\n        require(msg.sender == owner_xxx4);\n        owner_xxx4.transfer(reward_xxx4);\n        reward_xxx4 = msg.value;\n    }\n    function claimReward_xxx4(uint256 submission) public {\n        require (!claimed_xxx4);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx4);\n        claimed_xxx4 = true;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress payable winner_xxx5;\nfunction play_xxx5(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx5 = msg.sender;\n        }\n    }\nfunction getReward_xxx5() payable public{\n       winner_xxx5.transfer(msg.value);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool claimed_xxx8 = false;\naddress payable owner_xxx8;\nuint256 reward_xxx8;\nfunction setReward_xxx8() public payable {\n        require (!claimed_xxx8);\n        require(msg.sender == owner_xxx8);\n        owner_xxx8.transfer(reward_xxx8);\n        reward_xxx8 = msg.value;\n    }\n    function claimReward_xxx8(uint256 submission) public {\n        require (!claimed_xxx8);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx8);\n        claimed_xxx8 = true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress payable winner_xxx9;\nfunction play_xxx9(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx9 = msg.sender;\n        }\n    }\nfunction getReward_xxx9() payable public{\n       winner_xxx9.transfer(msg.value);\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\naddress payable winner_xxx11;\nfunction play_xxx11(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx11 = msg.sender;\n        }\n    }\nfunction getReward_xxx11() payable public{\n       winner_xxx11.transfer(msg.value);\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\naddress payable winner_xxx39;\nfunction play_xxx39(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx39 = msg.sender;\n        }\n    }\nfunction getReward_xxx39() payable public{\n       winner_xxx39.transfer(msg.value);\n    }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nbool claimed_xxx38 = false;\naddress payable owner_xxx38;\nuint256 reward_xxx38;\nfunction setReward_xxx38() public payable {\n        require (!claimed_xxx38);\n        require(msg.sender == owner_xxx38);\n        owner_xxx38.transfer(reward_xxx38);\n        reward_xxx38 = msg.value;\n    }\n    function claimReward_xxx38(uint256 submission) public {\n        require (!claimed_xxx38);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx38);\n        claimed_xxx38 = true;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nbool claimed_xxx10 = false;\naddress payable owner_xxx10;\nuint256 reward_xxx10;\nfunction setReward_xxx10() public payable {\n        require (!claimed_xxx10);\n        require(msg.sender == owner_xxx10);\n        owner_xxx10.transfer(reward_xxx10);\n        reward_xxx10 = msg.value;\n    }\n    function claimReward_xxx10(uint256 submission) public {\n        require (!claimed_xxx10);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx10);\n        claimed_xxx10 = true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nbool claimed_xxx12 = false;\naddress payable owner_xxx12;\nuint256 reward_xxx12;\nfunction setReward_xxx12() public payable {\n        require (!claimed_xxx12);\n        require(msg.sender == owner_xxx12);\n        owner_xxx12.transfer(reward_xxx12);\n        reward_xxx12 = msg.value;\n    }\n    function claimReward_xxx12(uint256 submission) public {\n        require (!claimed_xxx12);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx12);\n        claimed_xxx12 = true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress payable winner_xxx13;\nfunction play_xxx13(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx13 = msg.sender;\n        }\n    }\nfunction getReward_xxx13() payable public{\n       winner_xxx13.transfer(msg.value);\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress payable winner_xxx17;\nfunction play_xxx17(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx17 = msg.sender;\n        }\n    }\nfunction getReward_xxx17() payable public{\n       winner_xxx17.transfer(msg.value);\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nbool claimed_xxx16 = false;\naddress payable owner_xxx16;\nuint256 reward_xxx16;\nfunction setReward_xxx16() public payable {\n        require (!claimed_xxx16);\n        require(msg.sender == owner_xxx16);\n        owner_xxx16.transfer(reward_xxx16);\n        reward_xxx16 = msg.value;\n    }\n    function claimReward_xxx16(uint256 submission) public {\n        require (!claimed_xxx16);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx16);\n        claimed_xxx16 = true;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nbool claimed_xxx28 = false;\naddress payable owner_xxx28;\nuint256 reward_xxx28;\nfunction setReward_xxx28() public payable {\n        require (!claimed_xxx28);\n        require(msg.sender == owner_xxx28);\n        owner_xxx28.transfer(reward_xxx28);\n        reward_xxx28 = msg.value;\n    }\n    function claimReward_xxx28(uint256 submission) public {\n        require (!claimed_xxx28);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx28);\n        claimed_xxx28 = true;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nbool claimed_xxx14 = false;\naddress payable owner_xxx14;\nuint256 reward_xxx14;\nfunction setReward_xxx14() public payable {\n        require (!claimed_xxx14);\n        require(msg.sender == owner_xxx14);\n        owner_xxx14.transfer(reward_xxx14);\n        reward_xxx14 = msg.value;\n    }\n    function claimReward_xxx14(uint256 submission) public {\n        require (!claimed_xxx14);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx14);\n        claimed_xxx14 = true;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\naddress payable winner_xxx15;\nfunction play_xxx15(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx15 = msg.sender;\n        }\n    }\nfunction getReward_xxx15() payable public{\n       winner_xxx15.transfer(msg.value);\n    }\n}\ncontract LedgeriumToken is ERC20 {\n  address payable winner_xxx3;\nfunction play_xxx3(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx3 = msg.sender;\n        }\n    }\nfunction getReward_xxx3() payable public{\n       winner_xxx3.transfer(msg.value);\n    }\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\naddress payable winner_xxx29;\nfunction play_xxx29(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx29 = msg.sender;\n        }\n    }\nfunction getReward_xxx29() payable public{\n       winner_xxx29.transfer(msg.value);\n    }\n}",
    "type": "TOD"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function transferTo_xxx35(address to, uint amount,address owner_xxx35) public {\n  require(tx.origin == owner_xxx35);\n  to.call.value(amount);\n}\n  mapping (address => uint256) private _balances;\n  function sendto_xxx21(address payable receiver, uint amount,address owner_xxx21) public {\n\trequire (tx.origin == owner_xxx21);\n\treceiver.transfer(amount);\n}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx20(address owner_xxx20) public{\n        require(tx.origin == owner_xxx20);\n    }\n  uint256 private _totalSupply;\n  function withdrawAll_xxx34(address payable _recipient,address owner_xxx34) public {\n        require(tx.origin == owner_xxx34);\n        _recipient.transfer(address(this).balance);\n    }\n  string private _name;\n  function sendto_xxx1(address payable receiver, uint amount,address owner_xxx1) public {\n\trequire (tx.origin == owner_xxx1);\n\treceiver.transfer(amount);\n}\n  string private _symbol;\n  function withdrawAll_xxx2(address payable _recipient,address owner_xxx2) public {\n        require(tx.origin == owner_xxx2);\n        _recipient.transfer(address(this).balance);\n    }\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction transferTo_xxx7(address to, uint amount,address owner_xxx7) public {\n  require(tx.origin == owner_xxx7);\n  to.call.value(amount);\n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction withdrawAll_xxx6(address payable _recipient,address owner_xxx6) public {\n        require(tx.origin == owner_xxx6);\n        _recipient.transfer(address(this).balance);\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx40(address owner_xxx40) public{\n        require(tx.origin == owner_xxx40);\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx4(address owner_xxx4) public{\n        require(tx.origin == owner_xxx4);\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction sendto_xxx5(address payable receiver, uint amount,address owner_xxx5) public {\n\trequire (tx.origin == owner_xxx5);\n\treceiver.transfer(amount);\n}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx8(address owner_xxx8) public{\n        require(tx.origin == owner_xxx8);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction sendto_xxx9(address payable receiver, uint amount,address owner_xxx9) public {\n\trequire (tx.origin == owner_xxx9);\n\treceiver.transfer(amount);\n}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction transferTo_xxx11(address to, uint amount,address owner_xxx11) public {\n  require(tx.origin == owner_xxx11);\n  to.call.value(amount);\n}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction transferTo_xxx39(address to, uint amount,address owner_xxx39) public {\n  require(tx.origin == owner_xxx39);\n  to.call.value(amount);\n}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction withdrawAll_xxx38(address payable _recipient,address owner_xxx38) public {\n        require(tx.origin == owner_xxx38);\n        _recipient.transfer(address(this).balance);\n}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction withdrawAll_xxx10(address payable _recipient,address owner_xxx10) public {\n        require(tx.origin == owner_xxx10);\n        _recipient.transfer(address(this).balance);\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12(address owner_xxx12) public{\n        require(tx.origin == owner_xxx12);\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction sendto_xxx13(address payable receiver, uint amount,address owner_xxx13) public {\n\trequire (tx.origin == owner_xxx13);\n\treceiver.transfer(amount);\n}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction sendto_xxx17(address payable receiver, uint amount,address owner_xxx17) public {\n\trequire (tx.origin == owner_xxx17);\n\treceiver.transfer(amount);\n}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16(address owner_xxx16) public{\n        require(tx.origin == owner_xxx16);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28(  address owner_xxx28) public{\n        require(tx.origin == owner_xxx28);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction withdrawAll_xxx14(address payable _recipient,address owner_xxx14) public {\n        require(tx.origin == owner_xxx14);\n        _recipient.transfer(address(this).balance);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction transferTo_xxx15(address to, uint amount,address owner_xxx15) public {\n  require(tx.origin == owner_xxx15);\n  to.call.value(amount);\n}\n}\ncontract LedgeriumToken is ERC20 {\n  function transferTo_xxx3(address to, uint amount,address owner_xxx3) public {\n  require(tx.origin == owner_xxx3);\n  to.call.value(amount);\n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction sendto_xxx29(address payable receiver, uint amount,address owner_xxx29) public {\n\trequire (tx.origin == owner_xxx29);\n\treceiver.transfer(amount);\n}\n}",
    "type": "tx.origin"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx27() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (address => uint256) private _balances;\n  function xx_xxx32() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx26() payable public{\n      msg.sender.transfer(1 ether);}\n  uint256 private _totalSupply;\n  function xx_xxx22() payable public{\n      msg.sender.transfer(1 ether);}\n  string private _name;\n  function xx_xxx23() payable public{\n      msg.sender.transfer(1 ether);}\n  string private _symbol;\n  function xx_xxx21() payable public{\n      msg.sender.transfer(1 ether);}\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xx_xxx1() payable public{\n      msg.sender.transfer(1 ether);}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx2() payable public{\n      msg.sender.transfer(1 ether);}\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx3() payable public{\n      msg.sender.transfer(1 ether);}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction xx_xxx7() payable public{\n      msg.sender.transfer(1 ether);}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction xx_xxx6() payable public{\n      msg.sender.transfer(1 ether);}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx4() payable public{\n      msg.sender.transfer(1 ether);}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction xx_xxx5() payable public{\n      msg.sender.transfer(1 ether);}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx8() payable public{\n      msg.sender.transfer(1 ether);}\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx9() payable public{\n      msg.sender.transfer(1 ether);}\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xx_xxx11() payable public{\n      msg.sender.transfer(1 ether);}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx10() payable public{\n      msg.sender.transfer(1 ether);}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx12() payable public{\n      msg.sender.transfer(1 ether);}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx13() payable public{\n      msg.sender.transfer(1 ether);}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx17() payable public{\n      msg.sender.transfer(1 ether);}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx16() payable public{\n      msg.sender.transfer(1 ether);}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx28() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction xx_xxx14() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15() payable public{\n      msg.sender.transfer(1 ether);}\n}\ncontract LedgeriumToken is ERC20 {\n  function xx_xxx20() payable public{\n      msg.sender.transfer(1 ether);}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction xx_xxx29() payable public{\n      msg.sender.transfer(1 ether);}\n}",
    "type": "Unchecked-Send"
  },
  {
    "contract": "pragma solidity ^0.5.1;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xxsend_xxx2(address payable callee) public {\n    callee.send(5 ether);\n  }\n  mapping (address => uint256) private _balances;\n  function xx_xxx3(address payable addr) public\n      {addr.send (42 ether); }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  bool public payedOut_xxx45 = false;\nfunction withdrawLeftOver_xxx45() public {\n        require(payedOut_xxx45);\n        msg.sender.send(address(this).balance);\n    }\n  uint256 private _totalSupply;\n  function withdrawBal_xxx41 () public{\n\tuint64 Balances_xxx41 = 0;\n\tmsg.sender.send(Balances_xxx41);}\n  string private _name;\n  function xx_xxx7() public{\naddress payable addr_xxx7;\nif (!addr_xxx7.send (10 ether) || 1==1)\n\t{revert();}\n}\n  string private _symbol;\n  function xx_xxx6() public{\nuint receivers_xxx6;\naddress payable addr_xxx6;\nif (!addr_xxx6.send(42 ether))\n\t{receivers_xxx6 +=1;}\nelse\n\t{revert();}\n}\n  uint8 private _decimals;\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\nfunction xxExternalCall_xxx4 () public\n{  address payable addr_xxx4;\n   if (! addr_xxx4.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function name() public view returns (string memory) {\n        return _name;\n    }\nfunction xx_xxx42() public{\nuint receivers_xxx42;\naddress payable addr_xxx42;\nif (!addr_xxx42.send(42 ether))\n\t{receivers_xxx42 +=1;}\nelse\n\t{revert();}\n}\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\nfunction xx_xxx43() public{\naddress payable addr_xxx43;\nif (!addr_xxx43.send (10 ether) || 1==1)\n\t{revert();}\n}\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\nfunction withdrawBal_xxx5 () public{\n\tuint64 Balances_xxx5 = 0;\n\tmsg.sender.send(Balances_xxx5);}\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nbool public payedOut_xxx8 = false;\naddress payable public winner_xxx8;\nuint public winAmount_xxx8;\nfunction sendToWinner_xxx8() public {\n        require(!payedOut_xxx8);\n        winner_xxx8.send(winAmount_xxx8);\n        payedOut_xxx8 = true;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool public payedOut_xxx9 = false;\nfunction withdrawLeftOver_xxx9() public {\n        require(payedOut_xxx9);\n        msg.sender.send(address(this).balance);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction my_func_uncheck48(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction my_func_xxx11(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\nfunction xx_xxx39(address payable addr) public\n      {addr.send (4 ether); }\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\nfunction xxsend_xxx38(address payable callee) public {\n    callee.send(5 ether);\n  }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction cash_xxx10(uint roundIndex, uint subpotIndex,address payable winner_xxx10) public{\n        uint64 subpot_xxx10 = 10 ether;\n        winner_xxx10.send(subpot_xxx10);  \n        subpot_xxx10= 0;\n}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction my_func_uncheck12(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction callxx_xxx13(address callee) public {\n    callee.call.value(1 ether);\n  }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction withdrawBal_xxx17 () public{\n\tuint64 Balances_xxx17 = 0;\n\tmsg.sender.send(Balances_xxx17);}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xxExternalCall_xxx16 () public\n{  address payable addr_xxx16;\n   if (! addr_xxx16.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xxExternalCall_xxx28 () public\n{  address payable addr_xxx28;\n   if (! addr_xxx28.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction xxsend_xxx14(address payable callee) public {\n    callee.send(5 ether);\n  }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx15(address payable addr) public\n      {addr.send (42 ether); }\n}\ncontract LedgeriumToken is ERC20 {\n  function xxExternalCall_xxx40 () public\n{  address payable addr_xxx40;\n   if (! addr_xxx40.send (2 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n  uint256 public constant INITIAL_SUPPLY = 20000000000000000;\n    constructor () public ERC20(\"Ledgerium\", \"XLG\", 8) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\nfunction withdrawBal_xxx29 () public{\n\tuint Balances_xxx29 = 0;\n\tmsg.sender.send(Balances_xxx29);}\n}",
    "type": "Unhandled-Exceptions"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n    event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n    uint256[] private depositedKittiesArray;\n    mapping (uint256 => bool) private kittyIsDepositedInContract;\n    uint8 constant public decimals = 18;\n    string constant public name = \"Wrapped CryptoKitties\";\n    string constant public symbol = \"WCK\";\n    address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\n    function() external payable {}\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "correct"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  mapping(address => uint) balances_xxx31;\nfunction withdrawFunds_xxx31 (uint256 _weiToWithdraw) public {\n        require(balances_xxx31[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx31[msg.sender] -= _weiToWithdraw;\n    }\n  mapping (address => uint256) private _balances;\n  bool not_called_xxx27 = true;\nfunction xx_xxx27() public{\n        require(not_called_xxx27);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx27 = false;\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  mapping(address => uint) userBalance_xxx33;\nfunction withdrawBalance_xxx33() public{\n        (bool success,)= msg.sender.call.value(userBalance_xxx33[msg.sender])(\"\");\n        if( ! success ){\n            revert();\n        }\n        userBalance_xxx33[msg.sender] = 0;\n    }\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nbool not_called_xxx34 = true;\nfunction xx_xxx34() public{\n        require(not_called_xxx34);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx34 = false;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nmapping(address => uint) balances_xxx1;\n    function withdraw_balances_xxx1 () public {\n       (bool success,) =msg.sender.call.value(balances_xxx1[msg.sender ])(\"\");\n       if (success)\n          balances_xxx1[msg.sender] = 0;\n      }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress payable lastPlayer_xxx2;\n      uint jackpot_xxx2;\n\t  function buyTicket_xxx2() public{\n\t    if (!(lastPlayer_xxx2.send(jackpot_xxx2)))\n        revert();\n      lastPlayer_xxx2 = msg.sender;\n      jackpot_xxx2    = address(this).balance;\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx3;\nfunction withdrawFunds_xxx3 (uint256 _weiToWithdraw) public {\n        require(balances_xxx3[msg.sender] >= _weiToWithdraw);\n\t(bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx3[msg.sender] -= _weiToWithdraw;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nbool not_called_xxx41 = true;\nfunction xx_xxx41() public{\n        require(not_called_xxx41);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx41 = false;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nuint256 counter_xxx7 =0;\nfunction callme_xxx7() public{\n        require(counter_xxx7<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx7 += 1;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nbool not_called_xxx6 = true;\nfunction xx_xxx6() public{\n        require(not_called_xxx6);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx6 = false;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) userBalance_xxx40;\nfunction withdrawBalance_xxx40() public{\n        (bool success,)=msg.sender.call.value(userBalance_xxx40[msg.sender])(\"\");\n        if( ! success ){\n            revert();\n        }\n        userBalance_xxx40[msg.sender] = 0;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nmapping(address => uint) redeemableEther_xxx4;\nfunction claimReward_xxx4() public {        \n        require(redeemableEther_xxx4[msg.sender] > 0);\n        uint transferValue_xxx4 = redeemableEther_xxx4[msg.sender];\n        msg.sender.transfer(transferValue_xxx4);   \n        redeemableEther_xxx4[msg.sender] = 0;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nuint256 counter_xxx42 =0;\nfunction callme_xxx42() public{\n        require(counter_xxx42<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx42 += 1;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nmapping(address => uint) userBalance_xxx5;\nfunction withdrawBalance_xxx5() public{\n        if( ! (msg.sender.send(userBalance_xxx5[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx5[msg.sender] = 0;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nmapping(address => uint) balances_xxx8;\n    function withdraw_balances_xxx8 () public {\n       (bool success,) = msg.sender.call.value(balances_xxx8[msg.sender ])(\"\");\n       if (success)\n          balances_xxx8[msg.sender] = 0;\n      }\n}\ncontract ReentrancyGuard {\n  mapping(address => uint) redeemableEther_xxx32;\nfunction claimReward_xxx32() public {        \n        require(redeemableEther_xxx32[msg.sender] > 0);\n        uint transferValue_xxx32 = redeemableEther_xxx32[msg.sender];\n        msg.sender.transfer(transferValue_xxx32);   \n        redeemableEther_xxx32[msg.sender] = 0;\n    }\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\naddress payable lastPlayer_xxx9;\n      uint jackpot_xxx9;\n\t  function buyTicket_xxx9() public{\n\t    (bool success,) = lastPlayer_xxx9.call.value(jackpot_xxx9)(\"\");\n\t    if (!success)\n\t        revert();\n      lastPlayer_xxx9 = msg.sender;\n      jackpot_xxx9    = address(this).balance;\n    }\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  mapping(address => uint) balances_xxx15;\n    function withdraw_balances_xxx15 () public {\n       if (msg.sender.send(balances_xxx15[msg.sender ]))\n          balances_xxx15[msg.sender] = 0;\n      }\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  mapping(address => uint) balances_xxx29;\n    function withdraw_balances_xxx29 () public {\n       if (msg.sender.send(balances_xxx29[msg.sender ]))\n          balances_xxx29[msg.sender] = 0;\n      }\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  mapping(address => uint) userBalance_xxx26;\nfunction withdrawBalance_xxx26() public{\n        (bool success,)= msg.sender.call.value(userBalance_xxx26[msg.sender])(\"\");\n        if( ! success ){\n            revert();\n        }\n        userBalance_xxx26[msg.sender] = 0;\n    }\n  uint256[] private depositedKittiesArray;\n  mapping(address => uint) balances_xxx21;\n    function withdraw_balances_xxx21 () public {\n       (bool success,)= msg.sender.call.value(balances_xxx21[msg.sender ])(\"\");\n       if (success)\n          balances_xxx21[msg.sender] = 0;\n      }\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  mapping(address => uint) balances_xxx36;\n    function withdraw_balances_xxx36 () public {\n       if (msg.sender.send(balances_xxx36[msg.sender ]))\n          balances_xxx36[msg.sender] = 0;\n      }\n  uint8 constant public decimals = 18;\n  address payable lastPlayer_xxx37;\n      uint jackpot_xxx37;\n\t  function buyTicket_xxx37() public{\n\t    if (!(lastPlayer_xxx37.send(jackpot_xxx37)))\n        revert();\n      lastPlayer_xxx37 = msg.sender;\n      jackpot_xxx37    = address(this).balance;\n    }\n  string constant public name = \"Wrapped CryptoKitties\";\n  address payable lastPlayer_xxx23;\n      uint jackpot_xxx23;\n\t  function buyTicket_xxx23() public{\n\t    if (!(lastPlayer_xxx23.send(jackpot_xxx23)))\n        revert();\n      lastPlayer_xxx23 = msg.sender;\n      jackpot_xxx23    = address(this).balance;\n    }\n  string constant public symbol = \"WCK\";\n  uint256 counter_xxx35 =0;\nfunction callme_xxx35() public{\n        require(counter_xxx35<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx35 += 1;\n    }\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  uint256 counter_xxx21 =0;\nfunction callme_xxx21() public{\n        require(counter_xxx21<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx21 += 1;\n    }\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nmapping(address => uint) redeemableEther_xxx11;\nfunction claimReward_xxx11() public {        \n        require(redeemableEther_xxx11[msg.sender] > 0);\n        uint transferValue_xxx11 = redeemableEther_xxx11[msg.sender];\n        msg.sender.transfer(transferValue_xxx11);   \n        redeemableEther_xxx11[msg.sender] = 0;\n    }\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nmapping(address => uint) redeemableEther_xxx39;\nfunction claimReward_xxx39() public {        \n        require(redeemableEther_xxx39[msg.sender] > 0);\n        uint transferValue_xxx39 = redeemableEther_xxx39[msg.sender];\n        msg.sender.transfer(transferValue_xxx39);   \n        redeemableEther_xxx39[msg.sender] = 0;\n    }\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nmapping(address => uint) balances_xxx38;\nfunction withdrawFunds_xxx38 (uint256 _weiToWithdraw) public {\n        require(balances_xxx38[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx38[msg.sender] -= _weiToWithdraw;\n    }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nmapping(address => uint) balances_xxx10;\nfunction withdrawFunds_xxx10 (uint256 _weiToWithdraw) public {\n        require(balances_xxx10[msg.sender] >= _weiToWithdraw);\n        require(msg.sender.send(_weiToWithdraw));  \n        balances_xxx10[msg.sender] -= _weiToWithdraw;\n    }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nmapping(address => uint) userBalance_xxx12;\nfunction withdrawBalance_xxx12() public{\n        if( ! (msg.sender.send(userBalance_xxx12[msg.sender]) ) ){\n            revert();\n        }\n        userBalance_xxx12[msg.sender] = 0;\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\nbool not_called_xxx13 = true;\nfunction xx_xxx13() public{\n        require(not_called_xxx13);\n        (bool success,)=msg.sender.call.value(1 ether)(\"\");\n        if( ! success ){\n            revert();\n        }\n        not_called_xxx13 = false;\n    }\n    function() external payable {}\nmapping(address => uint) balances_xxx17;\nfunction withdrawFunds_xxx17 (uint256 _weiToWithdraw) public {\n        require(balances_xxx17[msg.sender] >= _weiToWithdraw);\n        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");\n        require(success);  \n        balances_xxx17[msg.sender] -= _weiToWithdraw;\n    }\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\naddress payable lastPlayer_xxx16;\n      uint jackpot_xxx16;\n\t  function buyTicket_xxx16() public{\n\t    if (!(lastPlayer_xxx16.send(jackpot_xxx16)))\n        revert();\n      lastPlayer_xxx16 = msg.sender;\n      jackpot_xxx16    = address(this).balance;\n    }\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nuint256 counter_xxx28 =0;\nfunction callme_xxx28() public{\n        require(counter_xxx28<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx28 += 1;\n    }\n    function transfer(address _to, uint256 _tokenId) external;\nuint256 counter_xxx14 =0;\nfunction callme_xxx14() public{\n        require(counter_xxx14<=5);\n\tif( ! (msg.sender.send(10 ether) ) ){\n            revert();\n        }\n        counter_xxx14 += 1;\n    }\n  bool not_called_xxx20 = true;\nfunction xx_xxx20() public{\n        require(not_called_xxx20);\n        if( ! (msg.sender.send(1 ether) ) ){\n            revert();\n        }\n        not_called_xxx20 = false;\n    }\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "Re-entrancy"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx19() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  mapping (address => uint256) private _balances;\n  mapping(address => uint) public lockTime_xxx25;\nfunction increaseLockTime_xxx25(uint _secondsToIncrease) public {\n        lockTime_xxx25[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx25() public {\n        require(now > lockTime_xxx25[msg.sender]);    \n        uint transferValue_xxx25 = 10;           \n        msg.sender.transfer(transferValue_xxx25);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function xx_xxx31() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nmapping(address => uint) public lockTime_xxx21;\nfunction increaseLockTime_xxx21(uint _secondsToIncrease) public {\n        lockTime_xxx21[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx21() public {\n        require(now > lockTime_xxx21[msg.sender]);    \n        uint transferValue_xxx21 = 10;           \n        msg.sender.transfer(transferValue_xxx21);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx20(uint8 p_xxx20) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx20;   \n}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nmapping(address => uint) balances_xxx34;\nfunction transfer_xxx34(address _to, uint _value) public returns (bool) {\n    require(balances_xxx34[msg.sender] - _value >= 0);  \n    balances_xxx34[msg.sender] -= _value;  \n    balances_xxx34[_to] += _value;  \n    return true;\n  }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nmapping(address => uint) public lockTime_xxx1;\nfunction increaseLockTime_xxx1(uint _secondsToIncrease) public {\n        lockTime_xxx1[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_ovrflow1() public {\n        require(now > lockTime_xxx1[msg.sender]);    \n        uint transferValue_xxx1 = 10;           \n        msg.sender.transfer(transferValue_xxx1);\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nmapping(address => uint) balances_xxx2;\nfunction transfer_undrflow2(address _to, uint _value) public returns (bool) {\n    require(balances_xxx2[msg.sender] - _value >= 0);  \n    balances_xxx2[msg.sender] -= _value;  \n    balances_xxx2[_to] += _value;  \n    return true;\n  }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx3() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx7() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nmapping(address => uint) balances_xxx6;\nfunction transfer_xxx62(address _to, uint _value) public returns (bool) {\n    require(balances_xxx6[msg.sender] - _value >= 0);  \n    balances_xxx6[msg.sender] -= _value;  \n    balances_xxx6[_to] += _value;  \n    return true;\n  }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx40(uint8 p_xxx40) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx40;   \n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx4(uint8 p_xxx4) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx4;   \n}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nmapping(address => uint) public lockTime_xxx5;\nfunction increaseLockTime_xxx5(uint _secondsToIncrease) public {\n        lockTime_xxx5[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx5() public {\n        require(now > lockTime_xxx5[msg.sender]);    \n        uint transferValue_xxx5 = 10;           \n        msg.sender.transfer(transferValue_xxx5);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx8(uint8 p_xxx8) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx8;   \n}\n}\ncontract ReentrancyGuard {\n  function xx_xxx27() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\nmapping(address => uint) public lockTime_xxx9;\nfunction increaseLockTime_xxx9(uint _secondsToIncrease) public {\n        lockTime_xxx9[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx9() public {\n        require(now > lockTime_xxx9[msg.sender]);    \n        uint transferValue_xxx9 = 10;           \n        msg.sender.transfer(transferValue_xxx9);\n    }\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  function xx_xxx15() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  mapping(address => uint) public lockTime_xxx29;\nfunction increaseLockTime_xxx29(uint _secondsToIncrease) public {\n        lockTime_xxx29[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx29() public {\n        require(now > lockTime_xxx29[msg.sender]);    \n        uint transferValue_xxx29 = 10;           \n        msg.sender.transfer(transferValue_xxx29);\n    }\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  mapping(address => uint) public lockTime_xxx33;\nfunction increaseLockTime_xxx33(uint _secondsToIncrease) public {\n        lockTime_xxx33[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx33() public {\n        require(now > lockTime_xxx33[msg.sender]);    \n        uint transferValue_xxx33 = 10;           \n        msg.sender.transfer(transferValue_xxx33);\n    }\n  uint256[] private depositedKittiesArray;\n  function xx_xxx32(uint8 p_xxx32) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx32;   \n}\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  mapping(address => uint) balances_xxx26;\nfunction transfer_xxx26(address _to, uint _value) public returns (bool) {\n    require(balances_xxx26[msg.sender] - _value >= 0);  \n    balances_xxx26[msg.sender] -= _value;  \n    balances_xxx26[_to] += _value;  \n    return true;\n  }\n  uint8 constant public decimals = 18;\n  mapping(address => uint) balances_xxx22;\nfunction transfer_xxx22(address _to, uint _value) public returns (bool) {\n    require(balances_xxx22[msg.sender] - _value >= 0);  \n    balances_xxx22[msg.sender] -= _value;  \n    balances_xxx22[_to] += _value;  \n    return true;\n  }\n  string constant public name = \"Wrapped CryptoKitties\";\n  function xx_xxx36(uint8 p_xxx36) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx36;   \n}\n  string constant public symbol = \"WCK\";\n  mapping(address => uint) public lockTime_xxx37;\nfunction increaseLockTime_xxx37(uint _secondsToIncrease) public {\n        lockTime_xxx37[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx37() public {\n        require(now > lockTime_xxx37[msg.sender]);    \n        uint transferValue_xxx37 = 10;           \n        msg.sender.transfer(transferValue_xxx37);\n    }\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  function xx_xxx23() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nfunction xx_xxx11() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nfunction xx_xxx39() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nmapping(address => uint) balances_xxx38;\nfunction transfer_xxx38(address _to, uint _value) public returns (bool) {\n    require(balances_xxx38[msg.sender] - _value >= 0);  \n    balances_xxx38[msg.sender] -= _value;  \n    balances_xxx38[_to] += _value;  \n    return true;\n  }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nmapping(address => uint) balances_xxx10;\nfunction transfer_xxx10(address _to, uint _value) public returns (bool) {\n    require(balances_xxx10[msg.sender] - _value >= 0);  \n    balances_xxx10[msg.sender] -= _value;  \n    balances_xxx10[_to] += _value;  \n    return true;\n  }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nfunction xx_xxx12(uint8 p_xxx12) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx12;   \n}\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\nmapping(address => uint) public lockTime_xxx13;\nfunction increaseLockTime_xxx13(uint _secondsToIncrease) public {\n        lockTime_xxx13[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx13() public {\n        require(now > lockTime_xxx13[msg.sender]);    \n        uint transferValue_xxx13 = 10;           \n        msg.sender.transfer(transferValue_xxx13);\n    }\n    function() external payable {}\nmapping(address => uint) public lockTime_xxx17;\nfunction increaseLockTime_xxx17(uint _secondsToIncrease) public {\n        lockTime_xxx17[msg.sender] += _secondsToIncrease;  \n    }\nfunction withdraw_xxx17() public {\n        require(now > lockTime_xxx17[msg.sender]);    \n        uint transferValue_xxx17 = 10;           \n        msg.sender.transfer(transferValue_xxx17);\n    }\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nfunction xx_xxx16(uint8 p_xxx16) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx16;   \n}\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nfunction xx_xxx28(uint8 p_xxx28) public{\n    uint8 vundflw1=0;\n    vundflw1 = vundflw1 + p_xxx28;   \n}\n    function transfer(address _to, uint256 _tokenId) external;\nmapping(address => uint) balances_xxx14;\nfunction transfer_xxx14(address _to, uint _value) public returns (bool) {\n    require(balances_xxx14[msg.sender] - _value >= 0);  \n    balances_xxx14[msg.sender] -= _value;  \n    balances_xxx14[_to] += _value;  \n    return true;\n  }\n  function xx_xxx35() public{\n    uint8 vundflw =0;\n    vundflw = vundflw -10;   \n}\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "Overflow-Underflow"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function xx_xxx33() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  mapping (address => uint256) private _balances;\n  function xx_xxx32 () public payable {\n\tuint pastBlockTime_xxx32; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx32); \n        pastBlockTime_xxx32 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  address winner_xxx26;\nfunction play_xxx26(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx26 = msg.sender;}}\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress winner_xxx2;\nfunction play_xxx2(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx2 = msg.sender;}}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\naddress winner_xxx3;\nfunction play_xxx3(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx3 = msg.sender;}}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\naddress winner_xxx7;\nfunction play_xxx7(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx7 = msg.sender;}}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\naddress winner_xxx6;\nfunction play_xxx6(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx6 = msg.sender;}}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx40 () public payable {\n\tuint pastBlockTime_xxx40; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx40); \n        pastBlockTime_xxx40 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx4 () public payable {\n\tuint pastBlockTime_xxx4; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx4); \n        pastBlockTime_xxx4 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx5() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx8 () public payable {\n\tuint pastBlockTime_xxx8; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx8); \n        pastBlockTime_xxx8 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx9() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\naddress winner_xxx11;\nfunction play_xxx11(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx11 = msg.sender;}}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\naddress winner_xxx39;\nfunction play_xxx39(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx39 = msg.sender;}}\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\naddress winner_xxx38;\nfunction play_xxx38(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx38 = msg.sender;}}\n}\ncontract ReentrancyGuard {\n  address winner_xxx22;\nfunction play_xxx22(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx22 = msg.sender;}}\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\naddress winner_xxx10;\nfunction play_xxx10(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx10 = msg.sender;}}\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\nuint256 xxv_xxx3 = block.timestamp;\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  uint256 xxv_xxx4 = block.timestamp;\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  uint256 xxv_xxx5 = block.timestamp;\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  function xx_xxx36 () public payable {\n\tuint pastBlockTime_xxx36; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx36); \n        pastBlockTime_xxx36 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  uint256[] private depositedKittiesArray;\n  function xx_xxx37() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  address winner_xxx23;\nfunction play_xxx23(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx23 = msg.sender;}}\n  uint8 constant public decimals = 18;\n  address winner_xxx35;\nfunction play_xxx35(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx35 = msg.sender;}}\n  string constant public name = \"Wrapped CryptoKitties\";\n  function xx_xxx21() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  string constant public symbol = \"WCK\";\n  function xx_xxx20 () public payable {\n\tuint pastBlockTime_xxx20; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx20); \n        pastBlockTime_xxx20 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  address winner_xxx34;\nfunction play_xxx34(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx34 = msg.sender;}}\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nfunction xx_xxx12 () public payable {\n\tuint pastBlockTime_xxx12; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx12); \n        pastBlockTime_xxx12 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nfunction xx_xxx13() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nfunction xx_xxx17() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nfunction xx_xxx16 () public payable {\n\tuint pastBlockTime_xxx16; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx16); \n        pastBlockTime_xxx16 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nfunction xx_xxx28 () public payable {\n\tuint pastBlockTime_xxx28; \n\trequire(msg.value == 10 ether); \n        require(now != pastBlockTime_xxx28); \n        pastBlockTime_xxx28 = now;       \n        if(now % 15 == 0) { \n            msg.sender.transfer(address(this).balance);\n        }\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\naddress winner_xxx14;\nfunction play_xxx14(uint startTime) public {\n\tif (startTime + (5 * 1 days) == block.timestamp){\n\t\twinner_xxx14 = msg.sender;}}\n    function() external payable {}\naddress winner_xxx15;\nfunction play_xxx15(uint startTime) public {\n\tuint _vtime = block.timestamp;\n\tif (startTime + (5 * 1 days) == _vtime){\n\t\twinner_xxx15 = msg.sender;}}\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nfunction xx_xxx29() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nuint256 xxv_xxx1 = block.timestamp;\n    function transfer(address _to, uint256 _tokenId) external;\nuint256 xxv_xxx2 = block.timestamp;\n  function xx_xxx1() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "Timestamp-Dependency"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  address payable winner_xxx19;\nfunction play_xxx19(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx19 = msg.sender;\n        }\n    }\nfunction getReward_xxx19() payable public{\n       winner_xxx19.transfer(msg.value);\n    }\n  mapping (address => uint256) private _balances;\n  address payable winner_xxx25;\nfunction play_xxx25(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx25 = msg.sender;\n        }\n    }\nfunction getReward_xxx25() payable public{\n       winner_xxx25.transfer(msg.value);\n    }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  address payable winner_xxx31;\nfunction play_xxx31(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx31 = msg.sender;\n        }\n    }\nfunction getReward_xxx31() payable public{\n       winner_xxx31.transfer(msg.value);\n    }\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\naddress payable winner_xxx21;\nfunction play_xxx21(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx21 = msg.sender;\n        }\n    }\nfunction getReward_xxx21() payable public{\n       winner_xxx21.transfer(msg.value);\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool claimed_xxx20 = false;\naddress payable owner_xxx20;\nuint256 reward_xxx20;\nfunction setReward_xxx20() public payable {\n        require (!claimed_xxx20);\n        require(msg.sender == owner_xxx20);\n        owner_xxx20.transfer(reward_xxx20);\n        reward_xxx20 = msg.value;\n    }\n    function claimReward_xxx20(uint256 submission) public {\n        require (!claimed_xxx20);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx20);\n        claimed_xxx20 = true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nbool claimed_xxx34 = false;\naddress payable owner_xxx34;\nuint256 reward_xxx34;\nfunction setReward_xxx34() public payable {\n        require (!claimed_xxx34);\n        require(msg.sender == owner_xxx34);\n        owner_xxx34.transfer(reward_xxx34);\n        reward_xxx34 = msg.value;\n    }\n    function claimReward_xxx34(uint256 submission) public {\n        require (!claimed_xxx34);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx34);\n        claimed_xxx34 = true;\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\naddress payable winner_xxx1;\nfunction play_xxx1(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx1 = msg.sender;\n        }\n    }\nfunction getReward_xxx1() payable public{\n       winner_xxx1.transfer(msg.value);\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nbool claimed_xxx2 = false;\naddress payable owner_xxx2;\nuint256 reward_xxx2;\nfunction setReward_xxx2() public payable {\n        require (!claimed_xxx2);\n        require(msg.sender == owner_xxx2);\n        owner_xxx2.transfer(reward_xxx2);\n        reward_xxx2 = msg.value;\n    }\n    function claimReward_xxx2(uint256 submission) public {\n        require (!claimed_xxx2);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx2);\n        claimed_xxx2 = true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\naddress payable winner_xxx3;\nfunction play_xxx3(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx3 = msg.sender;\n        }\n    }\nfunction getReward_xxx3() payable public{\n       winner_xxx3.transfer(msg.value);\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\naddress payable winner_xxx7;\nfunction play_xxx7(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx7 = msg.sender;\n        }\n    }\nfunction getReward_xxx7() payable public{\n       winner_xxx7.transfer(msg.value);\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nbool claimed_xxx6 = false;\naddress payable owner_xxx6;\nuint256 reward_xxx6;\nfunction setReward_xxx6() public payable {\n        require (!claimed_xxx6);\n        require(msg.sender == owner_xxx6);\n        owner_xxx6.transfer(reward_xxx6);\n        reward_xxx6 = msg.value;\n    }\n    function claimReward_xxx6(uint256 submission) public {\n        require (!claimed_xxx6);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx6);\n        claimed_xxx6 = true;\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nbool claimed_xxx40 = false;\naddress payable owner_xxx40;\nuint256 reward_xxx40;\nfunction setReward_xxx40() public payable {\n        require (!claimed_xxx40);\n        require(msg.sender == owner_xxx40);\n        owner_xxx40.transfer(reward_xxx40);\n        reward_xxx40 = msg.value;\n    }\n    function claimReward_xxx40(uint256 submission) public {\n        require (!claimed_xxx40);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx40);\n        claimed_xxx40 = true;\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nbool claimed_xxx4 = false;\naddress payable owner_xxx4;\nuint256 reward_xxx4;\nfunction setReward_xxx4() public payable {\n        require (!claimed_xxx4);\n        require(msg.sender == owner_xxx4);\n        owner_xxx4.transfer(reward_xxx4);\n        reward_xxx4 = msg.value;\n    }\n    function claimReward_xxx4(uint256 submission) public {\n        require (!claimed_xxx4);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx4);\n        claimed_xxx4 = true;\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\naddress payable winner_xxx5;\nfunction play_xxx5(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx5 = msg.sender;\n        }\n    }\nfunction getReward_xxx5() payable public{\n       winner_xxx5.transfer(msg.value);\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nbool claimed_xxx8 = false;\naddress payable owner_xxx8;\nuint256 reward_xxx8;\nfunction setReward_xxx8() public payable {\n        require (!claimed_xxx8);\n        require(msg.sender == owner_xxx8);\n        owner_xxx8.transfer(reward_xxx8);\n        reward_xxx8 = msg.value;\n    }\n    function claimReward_xxx8(uint256 submission) public {\n        require (!claimed_xxx8);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx8);\n        claimed_xxx8 = true;\n    }\n}\ncontract ReentrancyGuard {\n  address payable winner_xxx27;\nfunction play_xxx27(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx27 = msg.sender;\n        }\n    }\nfunction getReward_xxx27() payable public{\n       winner_xxx27.transfer(msg.value);\n    }\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\naddress payable winner_xxx9;\nfunction play_xxx9(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx9 = msg.sender;\n        }\n    }\nfunction getReward_xxx9() payable public{\n       winner_xxx9.transfer(msg.value);\n    }\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  address payable winner_xxx15;\nfunction play_xxx15(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx15 = msg.sender;\n        }\n    }\nfunction getReward_xxx15() payable public{\n       winner_xxx15.transfer(msg.value);\n    }\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  address payable winner_xxx29;\nfunction play_xxx29(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx29 = msg.sender;\n        }\n    }\nfunction getReward_xxx29() payable public{\n       winner_xxx29.transfer(msg.value);\n    }\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  address payable winner_xxx33;\nfunction play_xxx33(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx33 = msg.sender;\n        }\n    }\nfunction getReward_xxx33() payable public{\n       winner_xxx33.transfer(msg.value);\n    }\n  uint256[] private depositedKittiesArray;\n  bool claimed_xxx32 = false;\naddress payable owner_xxx32;\nuint256 reward_xxx32;\nfunction setReward_xxx32() public payable {\n        require (!claimed_xxx32);\n        require(msg.sender == owner_xxx32);\n        owner_xxx32.transfer(reward_xxx32);\n        reward_xxx32 = msg.value;\n    }\n    function claimReward_xxx32(uint256 submission) public {\n        require (!claimed_xxx32);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx32);\n        claimed_xxx32 = true;\n    }\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  bool claimed_xxx26 = false;\naddress payable owner_xxx26;\nuint256 reward_xxx26;\nfunction setReward_xxx26() public payable {\n        require (!claimed_xxx26);\n        require(msg.sender == owner_xxx26);\n        owner_xxx26.transfer(reward_xxx26);\n        reward_xxx26 = msg.value;\n    }\n    function claimReward_xxx26(uint256 submission) public {\n        require (!claimed_xxx26);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx26);\n        claimed_xxx26 = true;\n    }\n  uint8 constant public decimals = 18;\n  bool claimed_xxx22 = false;\naddress payable owner_xxx22;\nuint256 reward_xxx22;\nfunction setReward_xxx22() public payable {\n        require (!claimed_xxx22);\n        require(msg.sender == owner_xxx22);\n        owner_xxx22.transfer(reward_xxx22);\n        reward_xxx22 = msg.value;\n    }\n    function claimReward_xxx22(uint256 submission) public {\n        require (!claimed_xxx22);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx22);\n        claimed_xxx22 = true;\n    }\n  string constant public name = \"Wrapped CryptoKitties\";\n  bool claimed_xxx36 = false;\naddress payable owner_xxx36;\nuint256 reward_xxx36;\nfunction setReward_xxx36() public payable {\n        require (!claimed_xxx36);\n        require(msg.sender == owner_xxx36);\n        owner_xxx36.transfer(reward_xxx36);\n        reward_xxx36 = msg.value;\n    }\n    function claimReward_xxx36(uint256 submission) public {\n        require (!claimed_xxx36);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx36);\n        claimed_xxx36 = true;\n    }\n  string constant public symbol = \"WCK\";\n  address payable winner_xxx37;\nfunction play_xxx37(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx37 = msg.sender;\n        }\n    }\nfunction getReward_xxx37() payable public{\n       winner_xxx37.transfer(msg.value);\n    }\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  address payable winner_xxx23;\nfunction play_xxx23(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx23 = msg.sender;\n        }\n    }\nfunction getReward_xxx23() payable public{\n       winner_xxx23.transfer(msg.value);\n    }\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\naddress payable winner_xxx11;\nfunction play_xxx11(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx11 = msg.sender;\n        }\n    }\nfunction getReward_xxx11() payable public{\n       winner_xxx11.transfer(msg.value);\n    }\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\naddress payable winner_xxx39;\nfunction play_xxx39(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx39 = msg.sender;\n        }\n    }\nfunction getReward_xxx39() payable public{\n       winner_xxx39.transfer(msg.value);\n    }\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nbool claimed_xxx38 = false;\naddress payable owner_xxx38;\nuint256 reward_xxx38;\nfunction setReward_xxx38() public payable {\n        require (!claimed_xxx38);\n        require(msg.sender == owner_xxx38);\n        owner_xxx38.transfer(reward_xxx38);\n        reward_xxx38 = msg.value;\n    }\n    function claimReward_xxx38(uint256 submission) public {\n        require (!claimed_xxx38);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx38);\n        claimed_xxx38 = true;\n    }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nbool claimed_xxx10 = false;\naddress payable owner_xxx10;\nuint256 reward_xxx10;\nfunction setReward_xxx10() public payable {\n        require (!claimed_xxx10);\n        require(msg.sender == owner_xxx10);\n        owner_xxx10.transfer(reward_xxx10);\n        reward_xxx10 = msg.value;\n    }\n    function claimReward_xxx10(uint256 submission) public {\n        require (!claimed_xxx10);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx10);\n        claimed_xxx10 = true;\n    }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nbool claimed_xxx12 = false;\naddress payable owner_xxx12;\nuint256 reward_xxx12;\nfunction setReward_xxx12() public payable {\n        require (!claimed_xxx12);\n        require(msg.sender == owner_xxx12);\n        owner_xxx12.transfer(reward_xxx12);\n        reward_xxx12 = msg.value;\n    }\n    function claimReward_xxx12(uint256 submission) public {\n        require (!claimed_xxx12);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx12);\n        claimed_xxx12 = true;\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\naddress payable winner_xxx13;\nfunction play_xxx13(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx13 = msg.sender;\n        }\n    }\nfunction getReward_xxx13() payable public{\n       winner_xxx13.transfer(msg.value);\n    }\n    function() external payable {}\naddress payable winner_xxx17;\nfunction play_xxx17(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx17 = msg.sender;\n        }\n    }\nfunction getReward_xxx17() payable public{\n       winner_xxx17.transfer(msg.value);\n    }\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nbool claimed_xxx16 = false;\naddress payable owner_xxx16;\nuint256 reward_xxx16;\nfunction setReward_xxx16() public payable {\n        require (!claimed_xxx16);\n        require(msg.sender == owner_xxx16);\n        owner_xxx16.transfer(reward_xxx16);\n        reward_xxx16 = msg.value;\n    }\n    function claimReward_xxx16(uint256 submission) public {\n        require (!claimed_xxx16);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx16);\n        claimed_xxx16 = true;\n    }\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nbool claimed_xxx28 = false;\naddress payable owner_xxx28;\nuint256 reward_xxx28;\nfunction setReward_xxx28() public payable {\n        require (!claimed_xxx28);\n        require(msg.sender == owner_xxx28);\n        owner_xxx28.transfer(reward_xxx28);\n        reward_xxx28 = msg.value;\n    }\n    function claimReward_xxx28(uint256 submission) public {\n        require (!claimed_xxx28);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx28);\n        claimed_xxx28 = true;\n    }\n    function transfer(address _to, uint256 _tokenId) external;\nbool claimed_xxx14 = false;\naddress payable owner_xxx14;\nuint256 reward_xxx14;\nfunction setReward_xxx14() public payable {\n        require (!claimed_xxx14);\n        require(msg.sender == owner_xxx14);\n        owner_xxx14.transfer(reward_xxx14);\n        reward_xxx14 = msg.value;\n    }\n    function claimReward_xxx14(uint256 submission) public {\n        require (!claimed_xxx14);\n        require(submission < 10);\n        msg.sender.transfer(reward_xxx14);\n        claimed_xxx14 = true;\n    }\n  address payable winner_xxx35;\nfunction play_xxx35(bytes32 guess) public{\n       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {\n            winner_xxx35 = msg.sender;\n        }\n    }\nfunction getReward_xxx35() payable public{\n       winner_xxx35.transfer(msg.value);\n    }\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "TOD"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function transferTo_xxx19(address to, uint amount,address owner_xxx19) public {\n  require(tx.origin == owner_xxx19);\n  to.call.value(amount);\n}\n  mapping (address => uint256) private _balances;\n  function sendto_xxx25(address payable receiver, uint amount,address owner_xxx25) public {\n\trequire (tx.origin == owner_xxx25);\n\treceiver.transfer(amount);\n}\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function transferTo_xxx31(address to, uint amount,address owner_xxx31) public {\n  require(tx.origin == owner_xxx31);\n  to.call.value(amount);\n}\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction sendto_xxx21(address payable receiver, uint amount,address owner_xxx21) public {\n\trequire (tx.origin == owner_xxx21);\n\treceiver.transfer(amount);\n}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx20(address owner_xxx20) public{\n        require(tx.origin == owner_xxx20);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction withdrawAll_xxx34(address payable _recipient,address owner_xxx34) public {\n        require(tx.origin == owner_xxx34);\n        _recipient.transfer(address(this).balance);\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction sendto_xxx1(address payable receiver, uint amount,address owner_xxx1) public {\n\trequire (tx.origin == owner_xxx1);\n\treceiver.transfer(amount);\n}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction withdrawAll_xxx2(address payable _recipient,address owner_xxx2) public {\n        require(tx.origin == owner_xxx2);\n        _recipient.transfer(address(this).balance);\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction transferTo_xxx3(address to, uint amount,address owner_xxx3) public {\n  require(tx.origin == owner_xxx3);\n  to.call.value(amount);\n}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction transferTo_xxx7(address to, uint amount,address owner_xxx7) public {\n  require(tx.origin == owner_xxx7);\n  to.call.value(amount);\n}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction withdrawAll_xxx6(address payable _recipient,address owner_xxx6) public {\n        require(tx.origin == owner_xxx6);\n        _recipient.transfer(address(this).balance);\n    }\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx40(address owner_xxx40) public{\n        require(tx.origin == owner_xxx40);\n    }\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx4(address owner_xxx4) public{\n        require(tx.origin == owner_xxx4);\n    }\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction sendto_xxx5(address payable receiver, uint amount,address owner_xxx5) public {\n\trequire (tx.origin == owner_xxx5);\n\treceiver.transfer(amount);\n}\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx8(address owner_xxx8) public{\n        require(tx.origin == owner_xxx8);\n    }\n}\ncontract ReentrancyGuard {\n  function transferTo_xxx27(address to, uint amount,address owner_xxx27) public {\n  require(tx.origin == owner_xxx27);\n  to.call.value(amount);\n}\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\nfunction sendto_xxx9(address payable receiver, uint amount,address owner_xxx9) public {\n\trequire (tx.origin == owner_xxx9);\n\treceiver.transfer(amount);\n}\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  function transferTo_xxx15(address to, uint amount,address owner_xxx15) public {\n  require(tx.origin == owner_xxx15);\n  to.call.value(amount);\n}\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  function sendto_xxx29(address payable receiver, uint amount,address owner_xxx29) public {\n\trequire (tx.origin == owner_xxx29);\n\treceiver.transfer(amount);\n}\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  function sendto_xxx33(address payable receiver, uint amount,address owner_xxx33) public {\n\trequire (tx.origin == owner_xxx33);\n\treceiver.transfer(amount);\n}\n  uint256[] private depositedKittiesArray;\n  function xx_xxx32(  address owner_xxx32) public{\n        require(tx.origin == owner_xxx32);\n    }\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  function withdrawAll_xxx26(address payable _recipient,address owner_xxx26) public {\n        require(tx.origin == owner_xxx26);\n        _recipient.transfer(address(this).balance);\n    }\n  uint8 constant public decimals = 18;\n  function withdrawAll_xxx22(address payable _recipient,address owner_xxx22) public {\n        require(tx.origin == owner_xxx22);\n        _recipient.transfer(address(this).balance);\n    }\n  string constant public name = \"Wrapped CryptoKitties\";\n  function xx_xxx36(  address owner_xxx36) public{\n        require(tx.origin == owner_xxx36);\n    }\n  string constant public symbol = \"WCK\";\n  function sendto_xxx37(address payable receiver, uint amount,address owner_xxx37) public {\n\trequire (tx.origin == owner_xxx37);\n\treceiver.transfer(amount);\n}\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  function transferTo_xxx23(address to, uint amount,address owner_xxx23) public {\n  require(tx.origin == owner_xxx23);\n  to.call.value(amount);\n}\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nfunction transferTo_xxx11(address to, uint amount,address owner_xxx11) public {\n  require(tx.origin == owner_xxx11);\n  to.call.value(amount);\n}\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nfunction transferTo_xxx39(address to, uint amount,address owner_xxx39) public {\n  require(tx.origin == owner_xxx39);\n  to.call.value(amount);\n}\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nfunction withdrawAll_xxx38(address payable _recipient,address owner_xxx38) public {\n        require(tx.origin == owner_xxx38);\n        _recipient.transfer(address(this).balance);\n}\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nfunction withdrawAll_xxx10(address payable _recipient,address owner_xxx10) public {\n        require(tx.origin == owner_xxx10);\n        _recipient.transfer(address(this).balance);\n    }\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nfunction xx_xxx12(address owner_xxx12) public{\n        require(tx.origin == owner_xxx12);\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\nfunction sendto_xxx13(address payable receiver, uint amount,address owner_xxx13) public {\n\trequire (tx.origin == owner_xxx13);\n\treceiver.transfer(amount);\n}\n    function() external payable {}\nfunction sendto_xxx17(address payable receiver, uint amount,address owner_xxx17) public {\n\trequire (tx.origin == owner_xxx17);\n\treceiver.transfer(amount);\n}\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nfunction xx_xxx16(address owner_xxx16) public{\n        require(tx.origin == owner_xxx16);\n    }\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nfunction xx_xxx28(  address owner_xxx28) public{\n        require(tx.origin == owner_xxx28);\n    }\n    function transfer(address _to, uint256 _tokenId) external;\nfunction withdrawAll_xxx14(address payable _recipient,address owner_xxx14) public {\n        require(tx.origin == owner_xxx14);\n        _recipient.transfer(address(this).balance);\n    }\n  function transferTo_xxx35(address to, uint amount,address owner_xxx35) public {\n  require(tx.origin == owner_xxx35);\n  to.call.value(amount);\n}\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "tx.origin"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction xx_xxx32() payable public{\n      msg.sender.transfer(1 ether);}\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nfunction xx_xxx26() payable public{\n      msg.sender.transfer(1 ether);}\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction xx_xxx22() payable public{\n      msg.sender.transfer(1 ether);}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx23() payable public{\n      msg.sender.transfer(1 ether);}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx21() payable public{\n      msg.sender.transfer(1 ether);}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xx_xxx20() payable public{\n      msg.sender.transfer(1 ether);}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx1() payable public{\n      msg.sender.transfer(1 ether);}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx2() payable public{\n      msg.sender.transfer(1 ether);}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx3() payable public{\n      msg.sender.transfer(1 ether);}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction xx_xxx7() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nfunction xx_xxx6() payable public{\n      msg.sender.transfer(1 ether);}\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nfunction xx_xxx4() payable public{\n      msg.sender.transfer(1 ether);}\n}\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\nfunction xx_xxx5() payable public{\n      msg.sender.transfer(1 ether);}\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  function xx_xxx15() payable public{\n      msg.sender.transfer(1 ether);}\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  function xx_xxx29() payable public{\n      msg.sender.transfer(1 ether);}\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n    uint256[] private depositedKittiesArray;\n  function xx_xxx30() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  function xx_xxx24() payable public{\n      msg.sender.transfer(1 ether);}\n  uint8 constant public decimals = 18;\n  function xx_xxx18() payable public{\n      msg.sender.transfer(1 ether);}\n  string constant public name = \"Wrapped CryptoKitties\";\n  function xx_xxx19() payable public{\n      msg.sender.transfer(1 ether);}\n  string constant public symbol = \"WCK\";\n  function xx_xxx25() payable public{\n      msg.sender.transfer(1 ether);}\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  function xx_xxx31() payable public{\n      msg.sender.transfer(1 ether);}\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nfunction xx_xxx8() payable public{\n      msg.sender.transfer(1 ether);}\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nfunction xx_xxx9() payable public{\n      msg.sender.transfer(1 ether);}\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nfunction xx_xxx11() payable public{\n      msg.sender.transfer(1 ether);}\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nfunction xx_xxx10() payable public{\n      msg.sender.transfer(1 ether);}\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nfunction xx_xxx12() payable public{\n      msg.sender.transfer(1 ether);}\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\nfunction xx_xxx13() payable public{\n      msg.sender.transfer(1 ether);}\n    function() external payable {}\nfunction xx_xxx17() payable public{\n      msg.sender.transfer(1 ether);}\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nfunction xx_xxx16() payable public{\n      msg.sender.transfer(1 ether);}\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nfunction xx_xxx28() payable public{\n      msg.sender.transfer(1 ether);}\n    function transfer(address _to, uint256 _tokenId) external;\nfunction xx_xxx14() payable public{\n      msg.sender.transfer(1 ether);}\n  function xx_xxx27() payable public{\n      msg.sender.transfer(1 ether);}\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "Unchecked-Send"
  },
  {
    "contract": "pragma solidity ^0.5.8;\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n  function my_func_uncheck36(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n  mapping (address => uint256) private _balances;\n  function callxx_xxx37(address payable callee) public {\n    callee.call.value(1 ether);\n  }\n  mapping (address => mapping (address => uint256)) private _allowed;\n  function my_func_xxx23(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n  uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\nfunction xx_xxx3(address payable addr) public\n      {addr.send (42 ether); }\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\nbool public payedOut_xxx45 = false;\nfunction withdrawLeftOver_xxx45() public {\n        require(payedOut_xxx45);\n        msg.sender.send(address(this).balance);\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\nfunction withdrawBal_xxx41 () public{\n\tuint64 Balances_xxx41 = 0;\n\tmsg.sender.send(Balances_xxx41);}\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\nfunction xx_xxx7() public{\naddress payable addr_xxx7;\nif (!addr_xxx7.send (10 ether) || 1==1)\n\t{revert();}\n}\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\nfunction xx_xxx6() public{\nuint receivers_xxx6;\naddress payable addr_xxx6;\nif (!addr_xxx6.send(42 ether))\n\t{receivers_xxx6 +=1;}\nelse\n\t{revert();}\n}\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\nfunction xxExternalCall_xxx40 () public\n{  address payable addr_xxx40;\n   if (! addr_xxx40.send (2 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xxExternalCall_xxx4 () public\n{  address payable addr_xxx4;\n   if (! addr_xxx4.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\nfunction xx_xxx42() public{\nuint receivers_xxx42;\naddress payable addr_xxx42;\nif (!addr_xxx42.send(42 ether))\n\t{receivers_xxx42 +=1;}\nelse\n\t{revert();}\n}\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\nfunction xx_xxx43() public{\naddress payable addr_xxx43;\nif (!addr_xxx43.send (10 ether) || 1==1)\n\t{revert();}\n}\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\nfunction withdrawBal_xxx5 () public{\n\tuint64 Balances_xxx5 = 0;\n\tmsg.sender.send(Balances_xxx5);}\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\nbool public payedOut_xxx8 = false;\naddress payable public winner_xxx8;\nuint public winAmount_xxx8;\nfunction sendToWinner_xxx8() public {\n        require(!payedOut_xxx8);\n        winner_xxx8.send(winAmount_xxx8);\n        payedOut_xxx8 = true;\n    }\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\nbool public payedOut_xxx9 = false;\nfunction withdrawLeftOver_xxx9() public {\n        require(payedOut_xxx9);\n        msg.sender.send(address(this).balance);\n    }\n}\ncontract ReentrancyGuard {\n  function my_func_xxx35(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n  uint256 private _guardCounter;\n    constructor() public {\n        _guardCounter = 1;\n    }\nfunction my_func_uncheck48(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\ncontract WrappedCK is ERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n  function xx_xxx15(address payable addr) public\n      {addr.send (42 ether); }\n  event DepositKittyAndMintToken(\n        uint256 kittyId\n    );\n  function withdrawBal_xxx29 () public{\n\tuint Balances_xxx29 = 0;\n\tmsg.sender.send(Balances_xxx29);}\n  event BurnTokenAndWithdrawKitty(\n        uint256 kittyId\n    );\n  bool public payedOut_xxx21 = false;\nfunction withdrawLeftOver_xxx21() public {\n        require(payedOut_xxx21);\n        msg.sender.send(address(this).balance);\n    }\n  uint256[] private depositedKittiesArray;\n  bool public payedOut_xxx20 = false;\naddress payable public winner_xxx20;\nuint public winAmount_xxx20;\nfunction sendToWinner_xxx20() public {\n        require(!payedOut_xxx20);\n        winner_xxx20.send(winAmount_xxx20);\n        payedOut_xxx20 = true;\n    }\n  mapping (uint256 => bool) private kittyIsDepositedInContract;\n  function cash_xxx34(uint roundIndex, uint subpotIndex, address payable winner_xxx34) public{\n        uint64 subpot_xxx34 = 10 ether;\n        winner_xxx34.send(subpot_xxx34);  \n        subpot_xxx34= 0;\n}\n  uint8 constant public decimals = 18;\n  function callxx_xxx1(address payable callee) public {\n    callee.call.value(2 ether);\n  }\n  string constant public name = \"Wrapped CryptoKitties\";\n  function my_func_xxx47(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n  string constant public symbol = \"WCK\";\n  function cash_xxx46(uint roundIndex, uint subpotIndex, address payable winner_xxx46) public{\n        uint64 subpot_xxx46 = 3 ether;\n        winner_xxx46.send(subpot_xxx46);  \n        subpot_xxx46= 0;\n}\n  address public kittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  bool public payedOut_xxx44 = false;\naddress payable public winner_xxx44;\nuint public winAmount_xxx44;\nfunction sendToWinner_xxx44() public {\n        require(!payedOut_xxx44);\n        winner_xxx44.send(winAmount_xxx44);\n        payedOut_xxx44 = true;\n    }\n  KittyCore kittyCore;\n    function depositKittiesAndMintTokens(uint256[] calldata _kittyIds) external nonReentrant {\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        for(uint i = 0; i < _kittyIds.length; i++){\n            uint256 kittyToDeposit = _kittyIds[i];\n            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');\n            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');\n            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);\n            _pushKitty(kittyToDeposit);\n            emit DepositKittyAndMintToken(kittyToDeposit);\n        }\n        _mint(msg.sender, (_kittyIds.length).mul(10**18));\n    }\nfunction my_func_xxx11(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n    function burnTokensAndWithdrawKitties(uint256[] calldata _kittyIds, address[] calldata _destinationAddresses) external nonReentrant {\n        require(_kittyIds.length == _destinationAddresses.length, 'you did not provide a destination address for each of the cats you wish to withdraw');\n        require(_kittyIds.length > 0, 'you must submit an array with at least one element');\n        uint256 numTokensToBurn = _kittyIds.length;\n        require(balanceOf(msg.sender) >= numTokensToBurn.mul(10**18), 'you do not own enough tokens to withdraw this many ERC721 cats');\n        _burn(msg.sender, numTokensToBurn.mul(10**18));\n        for(uint i = 0; i < numTokensToBurn; i++){\n            uint256 kittyToWithdraw = _kittyIds[i];\n            if(kittyToWithdraw == 0){\n                kittyToWithdraw = _popKitty();\n            } else {\n                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');\n                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');\n                kittyIsDepositedInContract[kittyToWithdraw] = false;\n            }\n            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);\n            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);\n        }\n    }\nfunction xx_xxx39(address payable addr) public\n      {addr.send (4 ether); }\n    function _pushKitty(uint256 _kittyId) internal {\n        depositedKittiesArray.push(_kittyId);\n        kittyIsDepositedInContract[_kittyId] = true;\n    }\nfunction xxsend_xxx38(address payable callee) public {\n    callee.send(5 ether);\n  }\n    function _popKitty() internal returns(uint256){\n        require(depositedKittiesArray.length > 0, 'there are no cats in the array');\n        uint256 kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n        depositedKittiesArray.length--;\n        while(kittyIsDepositedInContract[kittyId] == false){\n            kittyId = depositedKittiesArray[depositedKittiesArray.length - 1];\n            depositedKittiesArray.length--;\n        }\n        kittyIsDepositedInContract[kittyId] = false;\n        return kittyId;\n    }\nfunction cash_xxx10(uint roundIndex, uint subpotIndex,address payable winner_xxx10) public{\n        uint64 subpot_xxx10 = 10 ether;\n        winner_xxx10.send(subpot_xxx10);  \n        subpot_xxx10= 0;\n}\n    function batchRemoveWithdrawnKittiesFromStorage(uint256 _numSlotsToCheck) external {\n        require(_numSlotsToCheck <= depositedKittiesArray.length, 'you are trying to batch remove more slots than exist in the array');\n        uint256 arrayIndex = depositedKittiesArray.length;\n        for(uint i = 0; i < _numSlotsToCheck; i++){\n            arrayIndex = arrayIndex.sub(1);\n            uint256 kittyId = depositedKittiesArray[arrayIndex];\n            if(kittyIsDepositedInContract[kittyId] == false){\n                depositedKittiesArray.length--;\n            } else {\n                return;\n            }\n        }\n    }\nfunction my_func_uncheck12(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n    constructor() public {\n        kittyCore = KittyCore(kittyCoreAddress);\n    }\nfunction callxx_xxx13(address callee) public {\n    callee.call.value(1 ether);\n  }\n    function() external payable {}\nfunction withdrawBal_xxx17 () public{\n\tuint64 Balances_xxx17 = 0;\n\tmsg.sender.send(Balances_xxx17);}\n}\ncontract KittyCore {\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\nfunction xxExternalCall_xxx16 () public\n{  address payable addr_xxx16;\n   if (! addr_xxx16.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\nfunction xxExternalCall_xxx28 () public\n{  address payable addr_xxx28;\n   if (! addr_xxx28.send (42 ether))  \n      {\n      }\n\telse\n      {\n      }\n}\n    function transfer(address _to, uint256 _tokenId) external;\nfunction xxsend_xxx14(address payable callee) public {\n    callee.send(5 ether);\n  }\n  function xxsend_xxx2(address payable callee) public {\n    callee.send(5 ether);\n  }\n  mapping (uint256 => address) public kittyIndexToApproved;\n}",
    "type": "Unhandled-Exceptions"
  }
]